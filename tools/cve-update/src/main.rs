/// CVE Feed Automation Tool
///
/// Fetches font-related CVEs from the National Vulnerability Database (NVD)
/// and generates signature files for automated vulnerability detection.

use anyhow::{Context, Result};
use chrono::{DateTime, Datelike, Utc};
use clap::Parser;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::fs;
use std::path::PathBuf;
use std::thread;
use std::time::Duration;

/// NVD API v2.0 endpoint
const NVD_API_URL: &str = "https://services.nvd.nist.gov/rest/json/cves/2.0";

/// Keywords to identify font-related CVEs
const FONT_KEYWORDS: &[&str] = &[
    "font",
    "truetype",
    "opentype",
    "type1",
    "cff",
    "woff",
    "ttf",
    "otf",
    "freetype",
    "harfbuzz",
    "fontforge",
    "adobe font",
    "postscript font",
    "embedded font",
    "glyph",
    "charstring",
    "hinting",
    "font parsing",
    "font rendering",
];

#[derive(Parser, Debug)]
#[command(name = "cve-update")]
#[command(about = "Fetch and generate font CVE signatures", long_about = None)]
struct Args {
    /// Output directory for signature files
    #[arg(short, long, default_value = "crates/font-analysis/signatures")]
    output: PathBuf,

    /// Start year for CVE search (inclusive)
    #[arg(long, default_value = "2020")]
    start_year: u32,

    /// End year for CVE search (inclusive, use current year if not specified)
    #[arg(long)]
    end_year: Option<u32>,

    /// NVD API key (optional, increases rate limit from 5 to 50 requests per 30 seconds)
    #[arg(long, env = "NVD_API_KEY")]
    api_key: Option<String>,

    /// Dry run - don't write files, just print what would be done
    #[arg(long)]
    dry_run: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// NVD API response structure (v2.0)
#[derive(Debug, Deserialize)]
struct NvdResponse {
    #[serde(rename = "vulnerabilities")]
    vulnerabilities: Vec<VulnerabilityItem>,
    #[serde(rename = "resultsPerPage")]
    results_per_page: u32,
    #[serde(rename = "startIndex")]
    start_index: u32,
    #[serde(rename = "totalResults")]
    total_results: u32,
}

#[derive(Debug, Deserialize)]
struct VulnerabilityItem {
    cve: CveItem,
}

#[derive(Debug, Deserialize)]
struct CveItem {
    id: String,
    descriptions: Vec<Description>,
    metrics: Option<Metrics>,
    references: Option<Vec<Reference>>,
    published: String,
}

#[derive(Debug, Deserialize)]
struct Description {
    lang: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct Metrics {
    #[serde(rename = "cvssMetricV31")]
    cvss_v31: Option<Vec<CvssMetric>>,
    #[serde(rename = "cvssMetricV2")]
    cvss_v2: Option<Vec<CvssMetric>>,
}

#[derive(Debug, Deserialize)]
struct CvssMetric {
    #[serde(rename = "cvssData")]
    cvss_data: CvssData,
}

#[derive(Debug, Deserialize)]
struct CvssData {
    #[serde(rename = "baseSeverity")]
    base_severity: Option<String>,
    #[serde(rename = "baseScore")]
    base_score: f32,
}

#[derive(Debug, Deserialize)]
struct Reference {
    url: String,
}

/// Signature file format (matches signatures.rs)
#[derive(Debug, Serialize)]
struct Signature {
    cve_id: String,
    description: String,
    severity: String,
    pattern: SignaturePattern,
    references: Vec<String>,
}

#[derive(Debug, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
enum SignaturePattern {
    /// Placeholder pattern - requires manual review
    Manual {
        note: String,
    },
}

fn main() -> Result<()> {
    let args = Args::parse();

    let end_year = args.end_year.unwrap_or_else(|| {
        let now: DateTime<Utc> = Utc::now();
        now.year() as u32
    });

    println!("CVE Feed Automation Tool");
    println!("========================");
    println!("Fetching CVEs from {} to {}", args.start_year, end_year);
    println!("Output directory: {}", args.output.display());
    println!();

    // Create output directory if it doesn't exist
    if !args.dry_run {
        fs::create_dir_all(&args.output)
            .context("Failed to create output directory")?;
    }

    // Fetch CVEs for each year
    let mut all_cves = Vec::new();
    for year in args.start_year..=end_year {
        println!("Fetching CVEs for year {}...", year);

        let cves = fetch_cves_for_year(year, &args)?;
        println!("  Found {} CVEs", cves.len());

        all_cves.extend(cves);

        // Rate limiting: NVD allows 5 requests per 30 seconds (or 50 with API key)
        if year < end_year {
            let delay = if args.api_key.is_some() { 1 } else { 6 };
            if args.verbose {
                println!("  Waiting {} seconds for rate limit...", delay);
            }
            thread::sleep(Duration::from_secs(delay));
        }
    }

    println!();
    println!("Total CVEs found: {}", all_cves.len());

    // Filter for font-related CVEs
    let font_cves: Vec<_> = all_cves
        .into_iter()
        .filter(|cve| is_font_related(cve))
        .collect();

    println!("Font-related CVEs: {}", font_cves.len());
    println!();

    // Generate signatures
    let mut generated_count = 0;
    let mut skipped_count = 0;

    for cve in &font_cves {
        let signature_path = args.output.join(format!("{}.yaml", cve.id.to_lowercase()));

        // Skip if signature already exists
        if signature_path.exists() {
            if args.verbose {
                println!("  Skipping {} (already exists)", cve.id);
            }
            skipped_count += 1;
            continue;
        }

        println!("Generating signature for {}...", cve.id);
        if args.verbose {
            println!("  Description: {}", get_description(cve));
        }

        let signature = generate_signature(cve);
        let yaml = serde_yaml::to_string(&vec![signature])
            .context("Failed to serialize signature")?;

        if args.dry_run {
            println!("  [DRY RUN] Would write to: {}", signature_path.display());
            if args.verbose {
                println!("{}", yaml);
            }
        } else {
            fs::write(&signature_path, yaml)
                .with_context(|| format!("Failed to write signature file: {}", signature_path.display()))?;
            println!("  Written to: {}", signature_path.display());
        }

        generated_count += 1;
    }

    println!();
    println!("Summary:");
    println!("  Generated: {}", generated_count);
    println!("  Skipped (existing): {}", skipped_count);
    println!("  Total: {}", font_cves.len());

    if generated_count > 0 {
        println!();
        println!("⚠️  NOTE: Generated signatures use placeholder patterns and require manual review!");
        println!("   Review each signature file and update the pattern field with specific detection logic.");
    }

    Ok(())
}

/// Check if a year is a leap year
fn is_leap_year(year: u32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// Get the last day of each month for a given year
fn get_month_ranges(year: u32) -> Vec<(&'static str, String)> {
    let feb_end = if is_leap_year(year) { "29" } else { "28" };

    vec![
        ("01-01", "01-31".to_string()),
        ("02-01", format!("02-{}", feb_end)),
        ("03-01", "03-31".to_string()),
        ("04-01", "04-30".to_string()),
        ("05-01", "05-31".to_string()),
        ("06-01", "06-30".to_string()),
        ("07-01", "07-31".to_string()),
        ("08-01", "08-31".to_string()),
        ("09-01", "09-30".to_string()),
        ("10-01", "10-31".to_string()),
        ("11-01", "11-30".to_string()),
        ("12-01", "12-31".to_string()),
    ]
}

/// Fetch CVEs for a specific year
fn fetch_cves_for_year(year: u32, args: &Args) -> Result<Vec<CveItem>> {
    let mut all_cves = Vec::new();

    // NVD API has strict date range limits - fetch monthly chunks
    let months = get_month_ranges(year);

    for (start_day, end_day) in months {
        let start_date = format!("{}-{}T00:00:00Z", year, start_day);
        let end_date = format!("{}-{}T23:59:59Z", year, end_day);

        if args.verbose {
            println!("  Fetching month: {} to {}", start_day, end_day);
        }

        let chunk_cves = fetch_cves_for_date_range(&start_date, &end_date, args)?;

        if args.verbose {
            println!("    Found {} CVEs in this month", chunk_cves.len());
        }

        all_cves.extend(chunk_cves);

        // Rate limiting between months - be conservative to avoid 429 errors
        // With API key: 50 req/30s → wait 2s to be safe
        // Without API key: 5 req/30s → wait 7s to be safe
        let delay = if args.api_key.is_some() { 2 } else { 7 };
        thread::sleep(Duration::from_secs(delay));
    }

    Ok(all_cves)
}

/// Fetch CVEs for a specific date range
fn fetch_cves_for_date_range(start_date: &str, end_date: &str, args: &Args) -> Result<Vec<CveItem>> {
    let mut all_cves = Vec::new();
    let mut start_index = 0;
    let results_per_page = 2000; // NVD max

    loop {
        let url = format!(
            "{}?pubStartDate={}&pubEndDate={}&resultsPerPage={}&startIndex={}",
            NVD_API_URL, start_date, end_date, results_per_page, start_index
        );

        if args.verbose {
            println!("  Fetching: {} (index {})", url, start_index);
        }

        // Retry with exponential backoff for 429 errors
        let nvd_response = retry_with_backoff(|| {
            let client = reqwest::blocking::Client::builder()
                .timeout(Duration::from_secs(30))
                .user_agent("sis-pdf-cve-update/0.1.0")
                .build()?;

            let mut request = client.get(&url);

            // Add API key if provided
            if let Some(api_key) = &args.api_key {
                request = request.header("apiKey", api_key);
            }

            let response = request.send()
                .context("Failed to fetch from NVD API")?;

            let status = response.status();

            if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
                // Return special error to trigger retry
                anyhow::bail!("RATE_LIMIT: 429 Too Many Requests");
            }

            if !status.is_success() {
                anyhow::bail!("NVD API returned status: {}", status);
            }

            response.json::<NvdResponse>()
                .context("Failed to parse NVD response")
        }, args.verbose)?;

        for vuln in nvd_response.vulnerabilities {
            all_cves.push(vuln.cve);
        }

        // Check if we need to fetch more
        if (start_index + results_per_page) >= nvd_response.total_results {
            break;
        }

        start_index += results_per_page;

        // Rate limiting between pagination requests
        // Use longer delay to be more conservative
        let delay = if args.api_key.is_some() { 2 } else { 7 };
        thread::sleep(Duration::from_secs(delay));
    }

    Ok(all_cves)
}

/// Retry a function with exponential backoff on rate limit errors
fn retry_with_backoff<F, T>(mut f: F, _verbose: bool) -> Result<T>
where
    F: FnMut() -> Result<T>,
{
    const MAX_RETRIES: u32 = 5;
    const INITIAL_BACKOFF_SECS: u64 = 10;

    for attempt in 0..MAX_RETRIES {
        match f() {
            Ok(result) => return Ok(result),
            Err(err) => {
                // Check if this is a rate limit error
                if err.to_string().contains("RATE_LIMIT") {
                    if attempt < MAX_RETRIES - 1 {
                        // Calculate exponential backoff: 10s, 20s, 40s, 80s
                        let backoff_secs = INITIAL_BACKOFF_SECS * 2_u64.pow(attempt);
                        println!("  ⚠️  Rate limit hit, waiting {} seconds before retry {}/{}...",
                                backoff_secs, attempt + 1, MAX_RETRIES);
                        thread::sleep(Duration::from_secs(backoff_secs));
                    } else {
                        anyhow::bail!("Rate limit exceeded after {} retries", MAX_RETRIES);
                    }
                } else {
                    // Non-rate-limit error, fail immediately
                    return Err(err);
                }
            }
        }
    }

    anyhow::bail!("Unexpected retry exhaustion")
}

/// Check if CVE is font-related based on description keywords
fn is_font_related(cve: &CveItem) -> bool {
    let description = get_description(cve).to_lowercase();

    FONT_KEYWORDS.iter().any(|keyword| description.contains(keyword))
}

/// Get English description from CVE
fn get_description(cve: &CveItem) -> String {
    cve.descriptions
        .iter()
        .find(|d| d.lang == "en")
        .map(|d| d.value.clone())
        .unwrap_or_else(|| "No description available".to_string())
}

/// Get severity from CVE metrics
fn get_severity(cve: &CveItem) -> String {
    if let Some(metrics) = &cve.metrics {
        // Try CVSS v3.1 first
        if let Some(cvss_v31) = &metrics.cvss_v31 {
            if let Some(metric) = cvss_v31.first() {
                if let Some(severity) = &metric.cvss_data.base_severity {
                    return severity.to_lowercase();
                }
            }
        }

        // Fallback to CVSS v2
        if let Some(cvss_v2) = &metrics.cvss_v2 {
            if let Some(metric) = cvss_v2.first() {
                let score = metric.cvss_data.base_score;
                return score_to_severity(score);
            }
        }
    }

    "medium".to_string()
}

/// Convert CVSS score to severity level
fn score_to_severity(score: f32) -> String {
    if score >= 9.0 {
        "critical".to_string()
    } else if score >= 7.0 {
        "high".to_string()
    } else if score >= 4.0 {
        "medium".to_string()
    } else {
        "low".to_string()
    }
}

/// Generate a signature for a CVE
fn generate_signature(cve: &CveItem) -> Signature {
    let description = get_description(cve);
    let severity = get_severity(cve);

    // Collect unique references
    let mut references = HashSet::new();

    // Add NVD link
    references.insert(format!("https://nvd.nist.gov/vuln/detail/{}", cve.id));

    // Add CVE references
    if let Some(refs) = &cve.references {
        for r in refs.iter().take(5) {
            // Limit to 5 additional references
            references.insert(r.url.clone());
        }
    }

    let references: Vec<String> = references.into_iter().collect();

    Signature {
        cve_id: cve.id.clone(),
        description: description.clone(),
        severity,
        pattern: SignaturePattern::Manual {
            note: "This signature requires manual review and pattern definition. See IMPLEMENTATION_PLAN.md section 2.4 for pattern types.".to_string(),
        },
        references,
    }
}
