#![forbid(unsafe_code)]

/// CVE Feed Automation Tool
///
/// Fetches CVEs from the National Vulnerability Database (NVD) that touch key PDF attack
/// surfaces and generates signature placeholders for manual review.
use anyhow::{Context, Result};
use chrono::{DateTime, Duration, NaiveDate, Utc};
use clap::Parser;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::thread;
use std::time::Duration as StdDuration;

/// NVD API v2.0 endpoint
const NVD_API_URL: &str = "https://services.nvd.nist.gov/rest/json/cves/2.0";

/// Keywords mapped to attack surface categories
const ATTACK_SURFACE_KEYWORDS: &[(&str, &str)] = &[
    ("font", "Font"),
    ("truetype", "Font"),
    ("opentype", "Font"),
    ("type1", "Font"),
    ("cff", "Font"),
    ("cff2", "Font"),
    ("woff", "Font"),
    ("ttf", "Font"),
    ("otf", "Font"),
    ("variable font", "Font"),
    ("freetype", "Font"),
    ("harfbuzz", "Font"),
    ("fontforge", "Font"),
    ("adobe font", "Font"),
    ("postscript font", "Font"),
    ("embedded font", "Font"),
    ("glyph", "Font"),
    ("charstring", "Font"),
    ("blend", "Font"),
    ("hinting", "Font"),
    ("font parsing", "Font"),
    ("font rendering", "Font"),
    ("jbig", "Image"),
    ("jbig2", "Image"),
    ("jpeg2000", "Image"),
    ("jpx", "Image"),
    ("jpeg", "Image"),
    ("jp2", "Image"),
    ("png", "Image"),
    ("tiff", "Image"),
    ("openjpeg", "Image"),
    ("libjpeg", "Image"),
    ("libpng", "Image"),
    ("image", "Image"),
    ("image codec", "Image"),
    ("image parsing", "Image"),
    ("zero-click", "Image"),
    ("zero click", "Image"),
    ("javascript", "JavaScript"),
    ("jscript", "JavaScript"),
    ("escript", "JavaScript"),
    ("formcalc", "JavaScript"),
    ("string.fromcharcode", "JavaScript"),
    ("util.printf", "JavaScript"),
    ("action", "Actions"),
    ("launch", "Actions"),
    ("gotoe", "Actions"),
    ("gotor", "Actions"),
    ("embeddedfile", "Actions"),
    ("uri", "Actions"),
    ("ntlm", "Actions"),
    ("smb", "Actions"),
    ("xfa", "Actions"),
    ("signature", "Crypto"),
    ("pdfex", "Crypto"),
    ("cbc", "Crypto"),
    ("aes", "Crypto"),
    ("xref", "Structure"),
    ("xrefs", "Structure"),
    ("objstm", "Structure"),
    ("incremental", "Structure"),
    ("polyglot", "Structure"),
    ("filter chain", "StreamsAndFilters"),
    ("filter obfuscation", "StreamsAndFilters"),
    ("sandbox", "Reader"),
    ("reader", "Reader"),
];

#[derive(Parser, Debug)]
#[command(name = "cve-update")]
#[command(
    about = "Fetch CVEs for sis's attack surfaces and emit signature placeholders",
    long_about = None
)]
struct Args {
    /// Output directory for signature files
    #[arg(short, long, default_value = "crates/font-analysis/signatures")]
    output: PathBuf,

    /// Additional directories that should receive the generated CVE signatures
    #[arg(long, value_name = "DIR")]
    extra_output: Vec<PathBuf>,

    /// NVD API key (optional, increases rate limit from 5 to 50 requests per 30 seconds)
    #[arg(long, env = "NVD_API_KEY")]
    api_key: Option<String>,

    /// Lookback window in days (ignored when --since is provided)
    #[arg(long, default_value_t = 7)]
    days: u32,

    /// Start date for the search window (YYYY-MM-DD). Overrides --days when set.
    #[arg(long)]
    since: Option<String>,

    /// End date for the search window (YYYY-MM-DD). Defaults to today.
    #[arg(long)]
    until: Option<String>,

    /// Dry run - don't write files, just print what would be done
    #[arg(long)]
    dry_run: bool,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Overwrite existing signature files
    #[arg(long)]
    force: bool,

    /// Threat intel tracker file to update with new CVEs
    #[arg(long, default_value = "docs/threat-intel-tracker.md")]
    tracker: PathBuf,
}

/// NVD API response structure (v2.0)
#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct NvdResponse {
    #[serde(rename = "vulnerabilities")]
    vulnerabilities: Vec<VulnerabilityItem>,
    #[serde(rename = "resultsPerPage")]
    results_per_page: u32,
    #[serde(rename = "startIndex")]
    start_index: u32,
    #[serde(rename = "totalResults")]
    total_results: u32,
}

#[derive(Debug, Deserialize)]
struct VulnerabilityItem {
    cve: CveItem,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct CveItem {
    id: String,
    descriptions: Vec<Description>,
    metrics: Option<Metrics>,
    references: Option<Vec<Reference>>,
    published: String,
}

#[derive(Debug, Deserialize)]
struct Description {
    lang: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct Metrics {
    #[serde(rename = "cvssMetricV31")]
    cvss_v31: Option<Vec<CvssMetric>>,
    #[serde(rename = "cvssMetricV2")]
    cvss_v2: Option<Vec<CvssMetric>>,
}

#[derive(Debug, Deserialize)]
struct CvssMetric {
    #[serde(rename = "cvssData")]
    cvss_data: CvssData,
}

#[derive(Debug, Deserialize)]
struct CvssData {
    #[serde(rename = "baseSeverity")]
    base_severity: Option<String>,
    #[serde(rename = "baseScore")]
    base_score: f32,
}

#[derive(Debug, Deserialize)]
struct Reference {
    url: String,
}

/// Signature file format (matches signatures.rs)
#[derive(Debug, Serialize)]
struct Signature {
    cve_id: String,
    description: String,
    severity: String,
    pattern: SignaturePattern,
    references: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    attack_surfaces: Vec<String>,
}

#[derive(Debug, Serialize)]
#[serde(tag = "type", rename_all = "snake_case")]
enum SignaturePattern {
    /// Placeholder pattern - requires manual review
    Manual { note: String },
}

fn main() -> Result<()> {
    let args = Args::parse();

    println!("CVE Feed Automation Tool");
    println!("========================");

    let (start_dt, end_dt) = determine_date_range(&args)?;
    let start_str = start_dt.format("%Y-%m-%dT00:00:00Z").to_string();
    let end_str = end_dt.format("%Y-%m-%dT23:59:59Z").to_string();
    println!("Window: {} → {}", start_dt.date_naive(), end_dt.date_naive());
    println!("Query: {} to {}", start_str, end_str);
    let mut output_dirs = vec![args.output.clone()];
    output_dirs.extend(args.extra_output.iter().cloned());
    output_dirs.sort();
    output_dirs.dedup();
    println!("Output directories:");
    for dir in &output_dirs {
        println!("  {}", dir.display());
    }
    println!();

    if !args.dry_run {
        for dir in &output_dirs {
            fs::create_dir_all(dir)
                .with_context(|| format!("Failed to create output directory: {}", dir.display()))?;
        }
    }

    let all_cves = fetch_cves_for_date_range(&start_str, &end_str, &args)?;
    println!();
    println!("Total CVEs found: {}", all_cves.len());

    let relevant_cves: Vec<_> = all_cves
        .into_iter()
        .map(|cve| {
            let description = get_description(&cve);
            let attack_surfaces = determine_attack_surfaces(&description);
            (cve, description, attack_surfaces)
        })
        .filter(|(_, _, surfaces)| !surfaces.is_empty())
        .collect();

    println!("Relevant CVEs for sis attack surfaces: {}", relevant_cves.len());
    println!();

    let mut generated_count = 0;
    let mut skipped_count = 0;

    for (cve, description, attack_surfaces) in &relevant_cves {
        let signature_file = format!("{}.yaml", cve.id.to_lowercase());
        let signature_paths: Vec<PathBuf> =
            output_dirs.iter().map(|dir| dir.join(&signature_file)).collect();
        let severity = get_severity(cve);

        if !args.dry_run {
            match update_tracker(&args.tracker, &cve.id, &severity, attack_surfaces) {
                Ok(true) => {
                    if args.verbose {
                        println!("  Tracker row added for {}", cve.id);
                    }
                }
                Ok(false) => {
                    if args.verbose {
                        println!("  Tracker already contains {}", cve.id);
                    }
                }
                Err(err) => {
                    eprintln!("  Failed to update tracker: {}", err);
                }
            }
        }

        let already_exists = signature_paths.iter().all(|path| path.exists());
        if already_exists && !args.force {
            if args.verbose {
                println!("  Skipping {} (already present in all outputs)", cve.id);
            }
            skipped_count += 1;
            continue;
        }

        println!(
            "Generating signature for {} (surfaces: {})...",
            cve.id,
            attack_surfaces.join(", ")
        );
        if args.verbose {
            println!("  Description: {}", description);
        }

        let signature = generate_signature(cve, description, &severity, attack_surfaces);
        let yaml =
            serde_yaml::to_string(&vec![signature]).context("Failed to serialize signature")?;

        if args.dry_run {
            for path in &signature_paths {
                println!("  [DRY RUN] Would write to: {}", path.display());
                if args.verbose {
                    println!("{}", yaml);
                }
            }
        } else {
            for path in &signature_paths {
                if path.exists() && !args.force {
                    if args.verbose {
                        println!("  Exists, skipping {:?}", path);
                    }
                    continue;
                }
                fs::write(path, &yaml).with_context(|| {
                    format!("Failed to write signature file: {}", path.display())
                })?;
                println!("  Written to: {}", path.display());
            }
        }

        generated_count += 1;
    }

    println!();
    println!("Summary:");
    println!("  Generated: {}", generated_count);
    println!("  Skipped (existing): {}", skipped_count);
    println!("  Total: {}", relevant_cves.len());

    if generated_count > 0 {
        println!();
        println!(
            "⚠️  NOTE: Generated signatures use placeholder patterns and require manual review!"
        );
        println!("   Review each signature file and update the pattern field with specific detection logic.");
    }

    Ok(())
}

/// Fetch CVEs for a specific date range
fn fetch_cves_for_date_range(
    start_date: &str,
    end_date: &str,
    args: &Args,
) -> Result<Vec<CveItem>> {
    let mut all_cves = Vec::new();
    let mut start_index = 0;
    let results_per_page = 2000; // NVD max

    loop {
        let url = format!(
            "{}?pubStartDate={}&pubEndDate={}&resultsPerPage={}&startIndex={}",
            NVD_API_URL, start_date, end_date, results_per_page, start_index
        );

        if args.verbose {
            println!("  Fetching: {} (index {})", url, start_index);
        }

        // Retry with exponential backoff for 429 errors
        let nvd_response = retry_with_backoff(
            || {
                let client = reqwest::blocking::Client::builder()
                    .timeout(StdDuration::from_secs(30))
                    .user_agent("sis-pdf-cve-update/0.1.0")
                    .build()?;

                let mut request = client.get(&url);

                // Add API key if provided
                if let Some(api_key) = &args.api_key {
                    request = request.header("apiKey", api_key);
                }

                let response = request.send().context("Failed to fetch from NVD API")?;

                let status = response.status();

                if status == reqwest::StatusCode::NOT_FOUND {
                    if args.verbose {
                        println!("  NVD API returned 404 Not Found, treating as empty result set");
                    }
                    return Ok(NvdResponse {
                        vulnerabilities: Vec::new(),
                        results_per_page,
                        start_index,
                        total_results: 0,
                    });
                }

                if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
                    // Return special error to trigger retry
                    anyhow::bail!("RATE_LIMIT: 429 Too Many Requests");
                }

                if !status.is_success() {
                    anyhow::bail!("NVD API returned status: {}", status);
                }

                response.json::<NvdResponse>().context("Failed to parse NVD response")
            },
            args.verbose,
        )?;

        for vuln in nvd_response.vulnerabilities {
            all_cves.push(vuln.cve);
        }

        // Check if we need to fetch more
        if (start_index + results_per_page) >= nvd_response.total_results {
            break;
        }

        start_index += results_per_page;

        // Rate limiting between pagination requests
        // Use longer delay to be more conservative
        let delay = if args.api_key.is_some() { 2 } else { 7 };
        thread::sleep(StdDuration::from_secs(delay));
    }

    Ok(all_cves)
}

/// Retry a function with exponential backoff on rate limit errors
fn retry_with_backoff<F, T>(mut f: F, _verbose: bool) -> Result<T>
where
    F: FnMut() -> Result<T>,
{
    const MAX_RETRIES: u32 = 5;
    const INITIAL_BACKOFF_SECS: u64 = 10;

    for attempt in 0..MAX_RETRIES {
        match f() {
            Ok(result) => return Ok(result),
            Err(err) => {
                // Check if this is a rate limit error
                if err.to_string().contains("RATE_LIMIT") {
                    if attempt < MAX_RETRIES - 1 {
                        // Calculate exponential backoff: 10s, 20s, 40s, 80s
                        let backoff_secs = INITIAL_BACKOFF_SECS * 2_u64.pow(attempt);
                        println!(
                            "  ⚠️  Rate limit hit, waiting {} seconds before retry {}/{}...",
                            backoff_secs,
                            attempt + 1,
                            MAX_RETRIES
                        );
                        thread::sleep(StdDuration::from_secs(backoff_secs));
                    } else {
                        anyhow::bail!("Rate limit exceeded after {} retries", MAX_RETRIES);
                    }
                } else {
                    // Non-rate-limit error, fail immediately
                    return Err(err);
                }
            }
        }
    }

    anyhow::bail!("Unexpected retry exhaustion")
}

/// Get English description from CVE
fn get_description(cve: &CveItem) -> String {
    cve.descriptions
        .iter()
        .find(|d| d.lang == "en")
        .map(|d| d.value.clone())
        .unwrap_or_else(|| "No description available".to_string())
}

/// Get severity from CVE metrics
fn get_severity(cve: &CveItem) -> String {
    if let Some(metrics) = &cve.metrics {
        // Try CVSS v3.1 first
        if let Some(cvss_v31) = &metrics.cvss_v31 {
            if let Some(metric) = cvss_v31.first() {
                if let Some(severity) = &metric.cvss_data.base_severity {
                    return severity.to_lowercase();
                }
            }
        }

        // Fallback to CVSS v2
        if let Some(cvss_v2) = &metrics.cvss_v2 {
            if let Some(metric) = cvss_v2.first() {
                let score = metric.cvss_data.base_score;
                return score_to_severity(score);
            }
        }
    }

    "medium".to_string()
}

/// Convert CVSS score to severity level
fn score_to_severity(score: f32) -> String {
    if score >= 9.0 {
        "critical".to_string()
    } else if score >= 7.0 {
        "high".to_string()
    } else if score >= 4.0 {
        "medium".to_string()
    } else {
        "low".to_string()
    }
}

/// Generate a signature for a CVE
fn generate_signature(
    cve: &CveItem,
    description: &str,
    severity: &str,
    attack_surfaces: &[String],
) -> Signature {
    // Collect unique references
    let mut references = HashSet::new();

    // Add NVD link
    references.insert(format!("https://nvd.nist.gov/vuln/detail/{}", cve.id));

    // Add CVE references
    if let Some(refs) = &cve.references {
        for r in refs.iter().take(5) {
            // Limit to 5 additional references
            references.insert(r.url.clone());
        }
    }

    let references: Vec<String> = references.into_iter().collect();

    let attack_surfaces = attack_surfaces.to_vec();

    Signature {
        cve_id: cve.id.clone(),
        description: description.to_string(),
        severity: severity.to_string(),
        pattern: SignaturePattern::Manual {
            note: "This signature requires manual review and pattern definition. See IMPLEMENTATION_PLAN.md section 2.4 for pattern types.".to_string(),
        },
        references,
        attack_surfaces,
    }
}

fn determine_attack_surfaces(description: &str) -> Vec<String> {
    let mut surfaces = HashSet::new();
    let lower = description.to_lowercase();
    for (keyword, surface) in ATTACK_SURFACE_KEYWORDS {
        if lower.contains(keyword) {
            surfaces.insert(surface.to_string());
        }
    }
    let mut list: Vec<String> = surfaces.into_iter().collect();
    list.sort();
    list
}

fn update_tracker(
    tracker_path: &Path,
    cve_id: &str,
    severity: &str,
    surfaces: &[String],
) -> Result<bool> {
    let content = fs::read_to_string(tracker_path).context("Failed to read tracker")?;
    let search_pattern = format!("| {} ", cve_id);
    if content.contains(&search_pattern) {
        return Ok(false);
    }

    let mut lines: Vec<String> = content.split('\n').map(String::from).collect();
    let insert_idx = lines
        .iter()
        .position(|line| line.trim_start().starts_with("|------"))
        .map(|idx| idx + 1)
        .unwrap_or(1);

    let date = Utc::now().format("%Y-%m-%d").to_string();
    let surfaces_label =
        if surfaces.is_empty() { "Unknown".to_string() } else { surfaces.join(", ") };
    let severity_label = title_case(severity);
    let note = format!(
        "Auto-added via cve-update; surfaces: {}. NVD: https://nvd.nist.gov/vuln/detail/{}",
        surfaces_label, cve_id
    );
    let row = format!(
        "| {} | {} | {} | TBD | {} | {} | Probable | {} |",
        date, cve_id, surfaces_label, severity_label, severity_label, note
    );

    lines.insert(insert_idx, row);
    let mut updated = lines.join("\n");
    if content.ends_with('\n') {
        updated.push('\n');
    }
    fs::write(tracker_path, updated).context("Failed to write tracker")?;
    Ok(true)
}

fn title_case(value: &str) -> String {
    let lower = value.to_ascii_lowercase();
    let mut chars = lower.chars();
    match chars.next() {
        Some(first) => {
            let mut title = String::new();
            title.push(first.to_ascii_uppercase());
            title.push_str(chars.as_str());
            title
        }
        None => String::new(),
    }
}

fn determine_date_range(args: &Args) -> Result<(DateTime<Utc>, DateTime<Utc>)> {
    if args.days == 0 {
        anyhow::bail!("--days must be at least 1");
    }
    let today = Utc::now().date_naive();
    let end_naive = if let Some(until_str) = &args.until { parse_date(until_str)? } else { today };
    let start_naive = if let Some(since_str) = &args.since {
        parse_date(since_str)?
    } else {
        end_naive
            .checked_sub_signed(Duration::days((args.days - 1) as i64))
            .ok_or_else(|| anyhow::anyhow!("Invalid date window"))?
    };
    if start_naive > end_naive {
        anyhow::bail!("start date must be before end date");
    }
    let start_dt = DateTime::from_naive_utc_and_offset(
        start_naive.and_hms_opt(0, 0, 0).expect("valid time"),
        Utc,
    );
    let end_dt = DateTime::from_naive_utc_and_offset(
        end_naive.and_hms_opt(23, 59, 59).expect("valid time"),
        Utc,
    );
    Ok((start_dt, end_dt))
}

fn parse_date(input: &str) -> Result<NaiveDate> {
    if let Ok(date) = NaiveDate::parse_from_str(input, "%Y-%m-%d") {
        return Ok(date);
    }
    if let Ok(dt) = DateTime::parse_from_rfc3339(input) {
        return Ok(dt.date_naive());
    }
    anyhow::bail!("Failed to parse date {}", input);
}
