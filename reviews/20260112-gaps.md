Deep Static Analysis Review of the sis-pdf Project
Capabilities

Embedded JavaScript Detection: The project robustly detects JavaScript content in PDFs. It flags the presence of JavaScript via keys like /JS or /JavaScript (e.g. a js_present finding) and even handles obfuscated cases. Sis-pdf includes an AST parser and an optional sandbox to analyze JavaScript code for dangerous API calls, timing evasions, and network behavior. This goes beyond simple keyword checks by reconstructing strings (e.g. decoding String.fromCharCode sequences) and identifying multiple JS entry points. The detection is comprehensive – for instance, it catches automatic triggers (/OpenAction, /AA events) and hidden or duplicate script references that might indicate malicious intent.

Embedded File & Attachment Analysis: Sis-pdf identifies file attachments and embedded files via structural markers and inspects their content. Any PDF object with /Type /EmbeddedFile is flagged (embedded_file_present). When found, sis-pdf decodes the file stream and computes a SHA-256 hash and file type “magic” signature (e.g. it recognizes MZ as PE executables, %PDF as nested PDF, PK... as Zip archives, ELF binaries, or #! as script files). This means if an attacker embeds an EXE, Office document (Zip), or script file, sis-pdf will note its type and size in the metadata. It even checks for encrypted Zip containers inside PDFs and flags those for further scrutiny. The filenames of attachments are captured and checked for tricks like double file extensions (e.g. .pdf.exe). In short, sis-pdf not only notices that a file is embedded, but also gives analysts a clue about what that file likely is (something legacy tools don’t do automatically).

Multimedia and Active Content: The scanner covers a range of non-text content that could hide exploits. It has detectors for multimedia streams and interactive media: for example, any use of Rich Media (embedded video/Flash content) triggers a richmedia_present finding, and it specifically flags 3D content (U3D/PRC streams) with a 3d_present alert. Likewise, presence of sound or movie objects yields a sound_movie_present finding. These indicate that the PDF contains embedded audio/video or Flash/animation content, which are often abused to exploit multimedia parser vulnerabilities. Sis-pdf treats these features as an expanded attack surface (raising at least a Medium severity). While it doesn’t execute or parse the multimedia content, identifying it is valuable since, for example, an embedded Flash (SWF) might contain ActionScript exploits. Additionally, sis-pdf catches interactive form content like AcroForm fields and XFA forms (acroform_present, xfa_present), which can embed scripts or logic in PDFs.

External Action Triggers: The tool detects PDF actions that launch external processes or URLs – common mechanisms for malware. It flags /Launch actions (launch_action_present) that attempt to run executables or open files, and it detects URI links (uri_present) to external resources. Sis-pdf goes a step further by classifying URL schemes (HTTP/HTTPS vs. javascript: vs. file paths) and scoring their risk level. For instance, a hidden, auto-triggered URL linking to an IP or suspicious domain would be noted with higher severity. It also catches SubmitForm actions (submitform_present) that could exfiltrate data, remote GoTo links (gotor_present for linking to external PDFs), and other risky actions. These detections ensure that any PDF trying to execute something on the host (like spawning a shell or connecting out) is flagged clearly.

Advanced Structural Anomalies: Sis-pdf’s static analysis isn’t limited to content; it also covers structural tricks attackers use. It will detect object stream usage and unusual object references (e.g. many compressed objects in an ObjStm or object ID re-use). For example, it flags object streams density (objstm_density_high) and gives summaries of objects embedded in streams. It also detects object ID shadowing (multiple versions of the same object ID) which can hide malicious revisions. Many of these structural issues (like multiple Xref tables, misplaced headers, EOF markers far from file end, etc.) are covered with dedicated findings (xref_conflict, missing_eof_marker, etc.), helping identify evasion techniques. In short, sis-pdf combines keyword-based detection with structural analysis and content-based heuristics, giving it a broad view of malicious indicators.

Gaps in Coverage

Despite its extensive coverage, the sis-pdf project has some notable gaps where certain embedded or scripting content is not yet explicitly detected:

Non-JavaScript Scripts (VBScript, etc.): Sis-pdf currently focuses on JavaScript and does not detect other script languages embedded in PDFs. For instance, a PDF might use a Launch action to run a Visual Basic Script (.vbs) or an AppleScript on macOS, or embed a shell script as an attachment. These would be generically flagged (e.g. as a launch or an embedded file) but there is no specific identifier that “this is VBScript code” or an AppleScript. The development notes acknowledge this gap: a planned detector for “non-JS scripting” (covering VBScript, AppleScript, shell scripts) is listed as missing. This means if an attacker found a way to trigger VBScript from a PDF (e.g. via an embedded .vbs file and a Launch action), sis-pdf would flag the Launch or embedded file, but might not recognize the file’s script language (it would likely label it “unknown” content unless a shebang is present). This is an area for improvement, since recognizing specific script content could allow tailored warnings (e.g. “Embedded VBScript file present”).

Flash/ActionScript Analysis: While sis-pdf catches the presence of Flash content (as part of RichMedia or as a movie stream), it does not actually inspect ActionScript or the internals of embedded Flash objects. The current detectors only report that a Flash or multimedia object exists (sound_movie_present or richmedia_present), without decompiling the SWF or analyzing its ActionScript code. The project’s own review marked this as a high-priority gap: “Missing: Flash SWF decompilation, ActionScript analysis”. In practice, this means if a malicious PDF contains a Flash exploit, sis-pdf will note that some Rich Media is present (useful as a signal) but won’t detail the payload inside the Flash. By contrast, a fully equipped analysis might extract the SWF and scan it for known malicious patterns. Sis-pdf plans to add findings like flash_actionscript_present or swf_embedded in the future, but as of now this remains a blind spot beyond simple presence detection.

Embedded Media Content Handling: Related to the above, sis-pdf doesn’t parse or emulate multimedia file formats that could be embedded. For example, PDF can embed 3D models (U3D/PRC) or audio/video files. Sis-pdf will alert that 3D content exists (3d_present), but it doesn’t inspect those binary streams further for malicious content. If an exploit were hiding in a malformed PRC 3D stream or in an embedded video codec, the tool wouldn’t specifically call that out beyond the fact that “3D content is present”. This is a relatively niche vector, but still a gap – essentially no deep parsing of non-PDF payloads like Flash, 3D, or media streams occurs in the static analysis.

Metadata and Steganography: The detection coverage has a gap in analyzing PDF metadata sections for anomalies. The /Info dictionary and XMP metadata can sometimes hide data or hints of tampering (e.g. extremely large metadata entries or suspicious keywords). The project notes that metadata-specific checks are “Missing” – there are no findings for metadata size or strange values. For example, a PDF could hide a malicious script in an XMP comment or have steganographic data in metadata; sis-pdf currently wouldn’t flag that. Adding detectors for things like unusually large metadata or known bad patterns (as planned with metadata_anomaly or info_dict_suspicious) would close this gap.

Heuristic Limits and False Negatives: Some content might slip through if it doesn’t trip the current rules. For instance, if a PDF embedded a script in an unusual way (not as a /JS object and not as an obvious file attachment), sis-pdf might not catch it. An example would be script code split across image metadata or encoded in a form calculation script – these are edge cases not explicitly covered in findings. The tool is heavily keyed to known PDF structures; truly novel or deeply obfuscated exploits (especially if they abuse PDF features that are less common) could evade detection. One known gap is circular object references (object graphs that loop) – these can be used to confuse parsers. Sis-pdf has object_id_shadowing detection for overlapping IDs, but it currently lacks a detector for outright cyclic references. Such a construct might be used to hide content in a way that a naive parser might skip, representing a potential blind spot until a dedicated check is implemented.

In summary, the major gaps lie in non-traditional scripts (anything not JavaScript), deep inspection of embedded non-PDF formats (Flash, media), and a few advanced structural areas. These gaps are recognized in the project’s roadmap and can be addressed by extending the detection rules and content analysis capabilities.

Object Stream Detection Techniques

Sis-pdf employs a combination of structural markers and limited content heuristics to determine the types of objects and streams in a PDF:

Reliance on PDF Structural Markers: For the most part, sis-pdf identifies object types using the PDF’s own metadata – i.e. dictionary keys and object context. Each PDF object’s dictionary is examined for known fields like /Type or /Subtype to classify it. For example, an object with << /Type /EmbeddedFile >> is recognized as an embedded file stream, /Subtype /Image would denote an image XObject, /JS or /JavaScript keys indicate a JavaScript action, /RichMedia flags a rich media annotation, etc. These explicit markers are the primary method of categorization. This means if the PDF is well-formed, sis-pdf can accurately tag streams as script, form, font, image, etc., based on how the PDF itself labels them. The advantage is efficiency and accuracy for known-good structures – it doesn’t guess the content but trusts the PDF’s own taxonomy.

Indirect Heuristics for Unmarked Streams: When structural clues are absent or minimal, sis-pdf falls back on simpler heuristics rather than deep file-type scanning. One example is its detection of HTML-like content in page streams: the content_html_payload finding searches text content for patterns like <html> or <script> that suggest an HTML/phishing payload embedded in a PDF page. This is a heuristic trigger – even if a content stream isn’t labeled as anything special, certain byte patterns will raise an alert. Another heuristic approach is counting filter chains: if a stream is compressed through many layers (/Filter chains), it flags that as suspicious (filter_chain_depth_high), on the assumption that very deep or nested filters might be hiding something. However, these are indirect signals (complexity or keyword presence) rather than actual format identification.

Magic Number Checks: Sis-pdf does perform some magic number analysis on decoded streams, but in a targeted way. Notably, for embedded file attachments (where it strongly expects a binary file payload), it will inspect the first bytes of the decoded data to guess the file type. The built-in logic looks for magic bytes corresponding to a few common formats: PE executables (MZ header) are identified as "pe", PDF files as "pdf" if a %PDF- header is found, ZIP archives (PK\x03\x04) as "zip", ELF binaries as "elf", and any data starting with a shebang (#!) as "script". If none of those match, it labels the content "unknown". This is useful for flagging when an embedded file is actually an EXE or Office document (Zip) in disguise. Beyond attachments, sis-pdf also uses magic signatures in its polyglot detection for whole files – scanning the beginning and end of the PDF for non-PDF file headers (PNG, JPG, HTML, etc.) that conflict with the %PDF- header. This can catch cases where a PDF is combined with another format (e.g., a PDF that is also an image or archive). However, outside of these scenarios, sis-pdf does not universally scan every stream’s bytes against a broad database of file signatures.

Object Stream (ObjStm) Handling: PDF object streams (which bundle many objects into one compressed stream) are a known evasion technique. Sis-pdf is designed to handle them: in deep scan mode, it automatically expands /ObjStm objects so that the individual embedded objects are analyzed. This ensures that scripts or actions aren’t missed just because they were hidden in a compressed object stream. The tool even has detectors that summarize or quantify object stream usage (like reporting how many objects are packed in streams via objstm_embedded_summary) and flagging if the density is abnormally high. The detection here relies on structural parsing: sis-pdf’s parser will read the ObjStm directory and extract contained objects, essentially neutralizing the hiding technique. It does not currently use external heuristics to identify object streams (it doesn’t need to — the PDF format defines them clearly), but it will note if an object stream’s presence seems intended to conceal content (e.g., when a normally singular object like the catalog is unnecessarily tucked into a stream).

No Full File-Type Cross-Referencing: Outside of the specific magic checks mentioned, sis-pdf does not cross-reference every stream against known file format headers. For example, if an image XObject stream’s data doesn’t actually match an image format (say an attacker mislabeled a malicious binary as an image), sis-pdf would likely not notice by content alone. It would trust the /Image label and perhaps the presence of image filters (DCTDecode, JPX, etc.) to assume it’s an image. There isn’t a routine to, for instance, verify that a DCTDecode stream starts with the 0xFFD8 JPEG marker. This is an area where more robust detection could improve reliability – adding deeper file signature checks or even integrating a library of file type detectors would catch mislabeled content. Currently, the approach is “trust but verify in key places”: trust the PDF structure, but verify known high-risk embeddings (attachments, overall file boundaries). Enhancing this with broad magic number scanning of all decoded streams could reveal stealthy cases (e.g., an exploit hidden in a stream masquerading as something else), at some cost of performance. The architecture is in place to do such decoding on-demand, so this is a possible future improvement.

In summary, sis-pdf primarily leverages explicit PDF structural cues to identify object types, augmented by targeted content checks (magic bytes for attachments, heuristic scans for suspicious text or polyglot signatures). This strategy covers most malicious content, but it could be strengthened by more comprehensive content-based identification (e.g., recognizing a Flash file in a stream by its FWS header, which currently would be labeled just “unknown”). The current balance keeps the analysis efficient while still catching blatant mismatches, but it assumes that truly covert payloads are at least hinted at by the PDF structure or simple patterns.

Comparative Benchmarking with Other PDF Analysis Tools

To put sis-pdf’s static analysis capabilities in context, here is a comparison with several other popular PDF analysis tools. We consider PDFiD, pdf-parser.py, peepdf, and PDF Examiner, focusing on their relative strengths and weaknesses in static detection of malicious PDFs:

PDFiD (Didier Stevens’ PDFiD)

Strengths: PDFiD is a lightweight triage tool that scans a PDF for the presence of suspicious keywords and structural features. It quickly counts occurrences of things like /JavaScript, /JS, /OpenAction, /AcroForm, /EmbeddedFile, etc., giving an immediate high-level profile of the file. Its simplicity is a major advantage – it runs fast, has no dependencies, and provides a clear output highlighting potentially dangerous elements (for example, if it shows /JS: 2 or /Launch: 1, the user knows the file contains scripting or launch actions). PDFiD is excellent for initial screening: it’s easy to integrate into automation and can process many files rapidly to flag those that deserve deeper analysis. It’s also very reliable for what it does; since it doesn’t fully parse the file, it’s less likely to choke on malformations (it just scans byte sequences).

Weaknesses: The flip side of PDFiD’s simplicity is its limited insight. It doesn’t understand context or content beyond counting. Malicious PDFs that hide their intent (e.g., heavily obfuscated JavaScript, or using uncommon keys or streams) might not be evident from PDFiD’s keyword counts. For instance, PDFiD will not decompress streams or reveal if a /JS is split across multiple objects or if a launch action’s target is suspicious – it only shows that the keywords exist. It cannot detect ActionScript in Flash, VBScript, or any embedded data that isn’t represented by a straightforward PDF keyword. In short, PDFiD may tell you “this PDF has one OpenAction and no JavaScript”, but it won’t tell you if that OpenAction launches calc.exe or if an embedded file is an EXE. It’s a blunt instrument compared to sis-pdf. Sis-pdf’s deeper parsing and semantic analysis far exceed PDFiD’s capabilities – for example, sis-pdf would flag a hidden JavaScript encoded in pieces (and even decode it), whereas PDFiD would miss it if no clear /JavaScript token is present. Essentially, PDFiD is quick but shallow, and it yields no severity or risk scoring. Analysts often use it as a first pass and then move to a more powerful tool like sis-pdf or pdf-parser for details.

pdf-parser.py (Didier Stevens’ PDF Parser)

Strengths: pdf-parser.py is a versatile manual analysis tool. It allows an analyst to inspect and extract parts of a PDF in detail. With pdf-parser, you can list all objects, filter objects by type or content, decompress streams, search for strings, and so forth. Its strength lies in user-driven flexibility: you can, for example, search for "/JS" and then easily dump the corresponding object’s stream to see the JavaScript, or extract an embedded file for analysis. It’s very stable and well-regarded – part of the “classic toolkit” for PDF forensics. It doesn’t automate decisions, but it gives a skilled user all the needed information. In terms of coverage, pdf-parser can reveal anything in the PDF because you can manually traverse every object. It’s particularly useful for confirming the output of automated tools or investigating tricky, obfuscated documents where you need to follow references step by step. Another benefit is that it’s scriptable: you can incorporate it into larger workflows or write Python scripts around it to perform batch tasks.

Weaknesses: The primary weakness is that pdf-parser is not an out-of-the-box detector – it’s only as effective as the analyst using it. It provides no scoring, no highlight of “this is bad”; the user must interpret everything. This makes it time-consuming for bulk analysis or triage. For example, pdf-parser will list an object that contains JavaScript but won’t automatically tell you if that script is malicious or even present – you have to know what to look for. It also doesn’t handle higher-level correlations (it won’t connect an action object to the payload object automatically – you must do that linkage mentally). In comparison to sis-pdf, pdf-parser lacks any built-in knowledge of exploits or threats. Sis-pdf will automatically flag a dozen different suspicious conditions (JavaScript in OpenAction, multiple Xref tables, etc.) and assign severity, whereas with pdf-parser you’d have to manually notice each of those patterns. In short, pdf-parser is powerful but manual. It can decode object streams and filters (with commands to decompress streams), but it requires user commands – sis-pdf does these things automatically in one run. For an inexperienced user, pdf-parser output can be overwhelming or easy to miss something. It’s best used by experts or in tandem with a tool like sis-pdf. In summary, pdf-parser is flexible and granular but not automated; sis-pdf is automated and comprehensive, but not interactive. They complement each other: sis-pdf can point out “here are suspicious areas,” and pdf-parser can then be used to dig into those specifics if needed.

Peepdf

Strengths: Peepdf is an interactive PDF analysis shell that was designed to be a one-stop tool for examining malicious PDFs. It parses the PDF structure and presents it to the user, similar to pdf-parser, but with a richer interactive experience (you can navigate objects in a shell and issue commands). One of peepdf’s big strengths is that it integrates additional analysis capabilities: it can decompress streams, handle object streams, and even integrate JavaScript analysis by hooking into a JavaScript engine (PyV8). This means peepdf can actually attempt to execute or emulate embedded JavaScript to see what it does (like deobfuscating it or detecting shellcode in memory). It also has a feature to use Pylibemu to detect or run shellcode that might be embedded in the PDF’s script (useful for exploits that include a second-stage payload). Peepdf supports all the common PDF filters and can parse multiple PDF versions (if the file has incremental updates) and encrypted PDFs. In essence, peepdf’s strength is comprehensiveness combined with interactivity – it tries to provide every piece of info (structure, content, decoded scripts) in one tool. It will highlight suspicious elements in its output (for example, it might mark objects containing JavaScript or Launch actions as suspicious), which is helpful for analysis. Compared to sis-pdf, peepdf was ahead of its time in offering an integrated JavaScript sandbox and even some exploit-specific scanning. For instance, peepdf could be used to automatically run the JavaScript to see if it’s exploiting util.printf() vulnerability, whereas sis-pdf’s approach is static (though sis-pdf does emulate some API patterns, it doesn’t fully execute scripts in a PDF runtime environment).

Weaknesses: Peepdf, while powerful, is less suited to high-volume or automated scanning. It’s an interactive tool (although it has a command-line mode, many features shine in the shell). This means using it on hundreds of files in an automated way is cumbersome compared to sis-pdf which is designed for batch scanning and JSON output. Another weakness is that peepdf’s development has slowed; some newer PDF features or evasion tricks might not be fully supported if the tool hasn’t been updated recently. For example, peepdf might not specifically flag a Flash object’s presence (it would show it as an object, but no built-in “flash detection” beyond listing a /RichMedia or /Flash filter if present). Also, setting up the PyV8 JavaScript engine or shellcode emulator can be tricky, and without those, its dynamic analysis is limited. Sis-pdf, being newer, incorporates more recent knowledge (like it knows about suspicious TLDs in URLs or modern phishing techniques), whereas peepdf’s rule-set is more static. In terms of user experience, sis-pdf produces a ready-made report of findings, whereas peepdf requires the analyst to interpret the structure – it might show object 12 has a /JavaScript, but it’s up to the user to investigate that object. Peepdf doesn’t assign severities or do correlation chains (it won’t automatically link an annotation trigger to the script object in a summarized “chain” like sis-pdf does). So, while peepdf is extremely powerful for digging into a single PDF and even testing its code, it’s heavier to use and not as focused on summarizing risk. In summary, peepdf excels as an analyst’s workbench tool, with strengths in dynamic analysis (JS/shellcode execution) that sis-pdf’s purely static approach doesn’t match. But sis-pdf outperforms peepdf in automation, up-to-date detection heuristics, and ease of use for reporting.

PDF Examiner (Malware Tracker’s PDF Examiner)

Strengths: PDF Examiner is an online static analysis service for PDFs. Its strength lies in combining signature-based detection of known PDF exploits with an interactive exploration interface. When you upload a PDF, it will scan for “several known exploits” (for example, it might recognize a PDF that targets CVE-2009-4324 by a pattern, or identify suspicious JavaScript by known malicious snippets). It then allows the user to click through the PDF’s structure in a tree view, inspect objects, and decode them on the fly – essentially a user-friendly front-end to a PDF parser with some malware knowledge built in. The benefit of PDF Examiner is that it’s very easy for an analyst to use without installing anything; and its knowledgebase of known exploits can pinpoint specific threats (e.g., “uses JBIG2 decode exploit” might be identified by it). It’s good for manual analysis with assistance – the tool might automatically highlight an object that looks like shellcode or obfuscated script as malicious. It also often provided quick decoding of common encodings and deobfuscation hints. Essentially, PDF Examiner’s strength is being a one-stop solution for analysts who want both automation (in terms of exploit scanning) and the ability to drill down manually, all via a GUI.

Weaknesses: As a static analyzer with a finite rule set, PDF Examiner can be limited when facing novel or heavily obfuscated attacks. Its detection is signature-based – which means if malware doesn’t match a known pattern, the tool may not flag it strongly aside from the generic presence of features. In contrast, sis-pdf uses a more behavior/heuristic-based approach (e.g., scoring a URL hidden with heavy obfuscation as high risk even if that exact pattern wasn’t seen before). Also, being an online tool, PDF Examiner might not be suitable for sensitive or very large files, whereas sis-pdf is offline and can be run in secure environments. In terms of coverage, PDF Examiner likely doesn’t handle things like embedded Flash analysis either (it might show an embedded file stream, but not analyze the SWF inside). It might also be behind on newer PDF features or evasion techniques if its development hasn’t kept pace. The lack of customization is another factor – with sis-pdf (or other offline tools) you can tweak or update them, but with a closed service like PDF Examiner, you rely on the maintainers. Finally, performance and scalability are concerns: sis-pdf can be integrated into automated pipelines processing thousands of files with its JSON output, whereas PDF Examiner is interactive and one-file-at-a-time (not counting any API, if one exists). In summary, PDF Examiner is user-friendly and knowledgeable about known attacks, which is great for quick analysis of a sample, but it doesn’t provide the depth of scanning across unknown attack vectors that sis-pdf does. Sis-pdf’s advantage is in its thoroughness and adaptability (covering structural oddities, scoring risk of content, etc.), while PDF Examiner’s advantage is convenience and specific exploit recognition.

Overall Perspective

In aggregate, sis-pdf stands out as a modern, comprehensive static analysis tool that attempts to combine many of the advantages of the above tools while minimizing their weaknesses. Unlike PDFiD, sis-pdf fully parses the file and doesn’t rely only on keyword counts (it finds hidden or indirect scripts, analyzes content, etc.). Unlike pdf-parser, it automatically surfaces suspicious elements and doesn’t require manual digging for each indicator (it produces a findings report with severities). Compared to peepdf, sis-pdf is more automation-friendly and has updated heuristics (though it doesn’t execute code like peepdf can with PyV8, which is one edge sis-pdf concedes in pure static vs dynamic capability). And relative to PDF Examiner, sis-pdf is not limited to known exploit signatures – it uses a structural and semantic approach, giving it better resilience against novel or obfuscated attacks. One could say sis-pdf’s strength is integrating the static structural analysis of traditional tools with a layer of intelligence and correlation (it builds an “attack chain” from triggers to payloads, and scores the risk, which none of the other tools do out-of-the-box). Its weakness might simply be that it’s newer and not as battle-tested as some tools like pdf-parser; there may be edge-case PDFs it struggles with (something those older tools or simpler scans might handle). Also, sis-pdf’s breadth means it’s a heavier solution – running it is more resource-intensive than a quick PDFiD scan. But for an in-depth static analysis, sis-pdf provides an unparalleled level of detail and automation in one package, effectively combining the detection coverage of multiple older tools (structure stats like PDFiD, content extraction like pdf-parser, and even some dynamic hinting akin to peepdf’s JavaScript analysis) into a single workflow. The trade-off is complexity and the need to keep its detectors updated as new PDF tricks emerge, but given its design, adding new detection rules (for example, for VBScript or Flash as discussed) is straightforward and on the roadmap.

Sources:

sis-pdf Documentation and Code – detection features and gaps

Didier Stevens’ PDF Tools (PDFiD, pdf-parser) – usage and scope

Peepdf README and description – capabilities of peepdf tool

Malware Tracker PDF Examiner – features of PDF Examiner service
