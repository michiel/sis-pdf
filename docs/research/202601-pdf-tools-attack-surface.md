# PDF Readers and Their Component Libraries (Attack Surface Overview)

## Key Component Types in PDF Rendering Engines

Before listing each reader, it’s important to define the main *component types* that process externally supplied data in PDFs (and thus present an attack surface):

-   Font Parsing/Rendering Engines: Handle embedded font files (TrueType, OpenType, Type1, etc.), often complex subsystems (e.g. Adobe’s *CoolType* font engine). Font engines parse font tables and execute font bytecode, making them prime targets for exploits.
-   Image Decoders and Filters: Parse image data and compression streams. PDFs can embed images in formats like JPEG, JPEG2000, JBIG2, etc., or use filters (Flate, LZW, ASCII85, CCITT fax) for compression. Readers typically include libraries to decode each image format (e.g. a JPEG2000 codec library). Vulnerabilities in these decoders (e.g. out-of-bounds in JPEG2000 or JBIG2 parsing) are common exploitation vectors.
-   JavaScript/Scripting Engines: Many readers support embedded JavaScript for interactive forms and actions. This is a full scripting engine (Adobe and Foxit embed browser engines like SpiderMonkey or V8). Bugs in these JS engines (or the PDF-specific APIs) can be exploited via malicious scripts. *(Note: Some readers choose to disable or omit JavaScript support for security.)*
-   Core PDF Parsing & Rendering Logic: The PDF file structure (parsing objects, cross-reference tables, etc.) is handled by the core engine or libraries (e.g. *Poppler* or *PDFium* in many readers). While often proprietary or custom, this layer may incorporate standard libraries for low-level tasks (e.g. zlib for Flate compression). Flaws here (like logic in Xref handling or object streams) can also be targeted.
-   Multimedia and 3D Content Handlers: Some readers support rich media (embedded video, audio) or 3D annotations. Historically, Adobe Reader included Flash and 3D parsers – e.g. an embedded Flash Player for `.swf` content and a 3D U3D/PRC renderer. These components (Flash, media codecs, 3D model parsers) expanded the attack surface in older versions (Flash was removed after 2020 when support ended).
-   Forms and External Services: PDF AcroForms and especially XFA forms use XML form content and sometimes proprietary form script engines (e.g. Adobe’s XFA uses an internal form engine in *AcroForm.api*). These involve XML parsers and form script interpreters that can be abused by crafted PDFs. Also, features like external links or launch actions can invoke system components (but those are usually constrained by the reader’s security settings).
    

With these categories in mind, we enumerate major PDF readers and the libraries or tools they use for each component type. We also note historical changes (older versions) where applicable.

## Adobe Acrobat/Reader (Adobe Reader)

-   Font Engine: Adobe uses a proprietary font parsing/rendering library called CoolType (packaged as *CoolType.dll* in Windows). This engine handles TrueType, Type1, etc., and has been the source of multiple critical vulnerabilities (e.g. heap overflows in embedded TrueType fonts). Older Acrobat on Windows also interfaced with the system’s Adobe Type Manager (ATMFD.dll) for some font types, which led to kernel-level font exploits (though not part of the Reader’s user-mode process).
-   Image Decoding: Acrobat includes dedicated libraries for images. Notably, it uses JP2KLib.dll for JPEG2000 decoding – vulnerabilities in this component (out-of-bounds reads/writes) have been exploited via malicious JP2 images in PDFs. For standard JPEG (DCTDecode) and other bitmaps, Adobe likely uses internal or third-party decoders (e.g. a module for JPEG, possibly leveraging libjpeg or a custom implementation). Acrobat’s JBIG2 decoder is built-in (responsible for parsing JBIG2 monochrome images); it famously had a critical bug in 2009 (improper handling of symbol dictionary segments) that allowed attackers to execute code. Other filters like Flate (ZIP/PNG compression) use zlib internally, and CCITT Fax decoding is handled by internal routines. Adobe Reader also supported parsing GIF, PNG, BMP, TIFF images in certain contexts (e.g. XFA forms), likely via integrated image IO libraries (or OS APIs) for those formats.
-   JavaScript Engine: Adobe Reader has a full JavaScript engine based on Mozilla’s SpiderMonkey (initially JavaScript 1.8). Embedded PDF scripts are executed by the *EScript.api* module, which wraps SpiderMonkey. This engine is old (as of 2018, Acrobat’s JS was ~8 years behind modern JS features). Many exploits target memory corruption in this JS engine or abuse its APIs; for example, attackers use PDF JavaScript to heap-spray memory and then trigger font or image bugs. *Older versions:* The JS engine has remained SpiderMonkey-based, but Adobe regularly patches it for vulnerabilities. (Acrobat does not use Google’s V8 – that is used by Foxit – see below.)
-   Core PDF Parser/Renderer: Acrobat’s core is proprietary, not using open-source renderers. It implements the PDF spec in-house (parsing objects, xref tables, graphics). Adobe’s core handles complex features like object streams, encryption, etc. It’s a large attack surface in itself (e.g. logic handling malformed PDF structures, overly permissive syntax tolerance). Adobe’s rendering integrates with system components for displaying output (e.g. on Windows, using GDI/Direct2D for drawing).
-   Forms and Interactive Content: Adobe Reader fully supports AcroForms and XFA forms. The *AcroForm.api* plugin (built-in) includes an XFA engine to parse XML form content and a FormCalc language interpreter. Past research showed XFA (which is essentially an embedded XML and script) could be abused for exploits. Additionally, Acrobat historically embedded a Flash Player for Rich Media Annotations (to play Flash/Video in PDFs). Until Flash EOL in 2020, this meant an older Flash runtime was bundled – a serious attack vector if Flash content was auto-played. Modern Acrobat no longer supports Flash content. Acrobat also supports 3D PDF content (U3D/PRC): it has a 3D rendering module that parses 3D model files inside PDF. There have been past vulnerabilities in Acrobat’s U3D parsing (e.g. memory corruption via malformed 3D data).
-   Security Evolution (Older vs Newer): Newer Adobe Reader versions run most content in a sandbox (“Protected Mode”) to contain exploits. Older versions (Acrobat 9 and earlier) had no sandbox – making any component RCE immediately critical. Attack surface components like CoolType and the JP2K/JBIG2 decoders had multiple CVEs fixed over the years. Adobe has since added mitigations (e.g. isolating font parsing in a sandbox process). Still, as of 2025, Adobe Reader’s rich feature set (JS, XFA, 3D, etc.) means it carries one of the largest attack surfaces among PDF readers.
    

## Foxit Reader

-   Font Parsing: Foxit’s PDF engine is based on its own code (which was later shared as PDFium to Google). For font rendering, Foxit uses the open-source FreeType library internally (albeit a subset of it, with custom patches). This handles TrueType/OpenType and Type1 fonts. Foxit may also use HarfBuzz for complex text shaping (not confirmed, but FreeType + HarfBuzz is a common pair for text layout). Historically, Foxit’s font handling had fewer public vulnerabilities than Adobe’s, but it’s equally complex (and would share any FreeType vulnerabilities if not updated promptly).
-   Image Decoders: Foxit Reader includes support for JPEG, PNG, BMP, etc., and had add-on plugins for JPEG2000 and JBIG2 in older versions. In Foxit Reader 2.x/3.x, the “JPEG2000/JBIG Decoder” add-on had to be installed separately, and it contained the JPEG2000 and JBIG2 parsing code. (A 2009 Foxit advisory notes a JBIG2 processing vulnerability in that plugin.) In later Foxit versions, these decoders are integrated by default. Under the hood, Foxit’s JPX (JPEG2000) decoder is likely based on OpenJPEG or a similar library (since PDFium, originating from Foxit, uses OpenJPEG). For JBIG2, Foxit either implemented its own or licensed one (PDFium’s JBIG2 decoder is derived from the open jbig2dec). Other filters: Flate (zlib), CCITT fax, etc., are handled by standard libraries (zlib is used for Flate).
-   JavaScript Engine: Foxit Reader uses Google’s V8 JavaScript engine internally. This was a notable design choice to support PDF scripts. However, Foxit’s updates to V8 lag behind – in 2022, researchers found Foxit was using V8 version 7.7.299.6 (from 2019), containing known Chrome exploits. Indeed, an RCE was achieved by exploiting a known V8 bug (CVE-2020-6418) in a malicious PDF. Foxit patched this by removing some JS features rather than fully updating V8. In summary, Foxit’s JavaScript support = V8 engine, making any V8 vulnerability an issue if the engine isn’t kept updated. (Older Foxit versions around 2008 had a simpler JS engine with limited support, but modern Foxit fully supports Acrobat JS APIs via V8.)
-   Core PDF Engine: Foxit’s core parser and renderer is proprietary but became the basis of PDFium (Foxit contributed their engine to Chrome around 2014). It’s written in C/C++ and uses many third-party components (FreeType, etc. as noted). The core is responsible for PDF structure, XFA forms (Foxit does support XFA dynamic forms to an extent), and rendering. Foxit’s renderer is known for being fast, and the company also offers it as an SDK. Any logic bug in parsing (xref handling, etc.) could affect Foxit and by extension PDFium-based viewers.
-   Forms/Misc: Foxit Reader supports AcroForms fully, and newer versions claim *partial XFA form* support. It likely has an internal XFA processing module (or omits unsupported pieces). Unlike Adobe, Foxit did not include Flash/3D – it sticks to core PDF features. This narrower focus means Foxit’s multimedia attack surface is smaller (no Flash player component, etc.). However, Foxit in the past did allow embedding external links/actions, which they now restrict with a Safe Reading Mode by default.
-   Older Version Notes: As mentioned, Foxit Reader 2.x/3.x had certain features as plugins (reducing default attack surface unless the user installed them). By Foxit Reader 4 and above, most features were integrated. Over time Foxit also added a sandbox (in recent versions) to catch exploits. But older Foxit (pre-2017) had no sandbox and was vulnerable to many of the same font/image issues as Adobe (over 50 CVEs were found in Foxit in recent years by researchers fuzzing the PDF features).
    

## Poppler-based Viewers (Linux: Evince, Okular, etc.)

*Poppler* is an open-source PDF rendering library (a fork of Xpdf) used by many Linux viewers (Evince for GNOME, Okular for KDE, etc.). These applications share the same backend, so their attack surface is essentially Poppler’s components:

-   Font Engine: Poppler relies on FreeType for all font parsing and rasterization. Xpdf (its predecessor) had its own font code, but Poppler uses FreeType for TrueType, OpenType, Type1 fonts, etc., which improves compatibility. FreeType’s hinting VM and font table parsing thus run when a PDF has embedded fonts. Any FreeType vulnerabilities (e.g. in CFF parsing or new font features) can impact Poppler-based viewers. (Poppler also can use HarfBuzz for text shaping of complex scripts if compiled with it, improving text rendering but adding that library to the mix.)
-   Image Decoders: Poppler uses standard libraries for images: libjpeg for JPEG images, libpng for images with PNG compression (if any), and OpenJPEG for JPEG2000 (JPXDecode) support. Poppler 0.9+ added JPEG2000 via OpenJPEG; earlier, PDFs with JP2 images couldn’t be rendered. For JBIG2, Poppler uses the open-source jbig2dec decoder (the same one originally developed for Xpdf/Ghostscript). jbig2dec has had its own share of bugs, so Poppler updates it as needed. Other filters: Poppler uses zlib for Flate (ZIP) compression, and has built-in decoders for ASCII85, RunLength, and CCITT Fax (some of these might leverage libtiff or custom code). Overall, Poppler’s image parsing is comprehensive, and past vulnerabilities in OpenJPEG or jbig2dec (buffer overflows, etc.) have affected it.
-   JavaScript: No JavaScript support is enabled in Poppler by default. Poppler (up to current versions) does *not* execute embedded PDF JavaScript. An experimental JS support was introduced in a development branch in 2008 (using Mozilla’s SpiderMonkey), but this never became part of stable Poppler or was later removed. Therefore, Evince/Okular do not run PDF-embedded scripts, eliminating that attack vector entirely. (Interactive forms in these viewers are limited to basic field actions without script execution.)
-   Core Parsing/Rendering: Poppler’s core is derived from Xpdf 3.0 code. It handles PDF parsing, XRef tables, streams, and rendering (via either Splash or Cairo graphics backends). Poppler has had numerous security fixes over time for parsing logic (e.g. handling malformed files, object streams, etc.), given it’s widely used in servers as well. It also supports AcroForms (filling forms) but does not support XFA forms at all (XFA PDFs simply won’t render properly in Poppler viewers). This lack of XFA and JS support limits the attack surface significantly – many malware PDFs that rely on those features will lose functionality. However, Poppler viewers are still vulnerable to font/image exploits as noted.
-   Notable Differences in Versions: Because Poppler is open-source, Linux distributions keep it updated. Older Poppler (e.g. 2010 era) lacked JPEG2000 or had early jbig2dec versions – meaning they might fail to render some content but also were free of those specific parser bugs. Modern Poppler includes these and hence must update those libraries for security. Evince/Okular themselves are thin wrappers; the heavy lifting is in libpoppler. In practice, any CVE in FreeType, OpenJPEG, jbig2dec, or Poppler’s core flows down to all these readers until patched.
    

## MuPDF (and Sumatra PDF)

MuPDF is a lightweight PDF renderer by Artifex (makers of Ghostscript). It’s used in the Sumatra PDF viewer on Windows and in other lightweight apps. MuPDF focuses on simplicity and speed, using a small set of third-party libraries:

-   Font Engine: MuPDF uses FreeType 2 for font rasterization, similar to Poppler, and thus supports TrueType, OpenType, Type1 via FreeType’s code. For text shaping (needed for complex scripts), MuPDF integrates HarfBuzz as well. This means MuPDF’s font parsing is largely in well-known libraries. (MuPDF historically had its own Type3 font interpreter and uses FreeType’s APIs for others.)
-   Image Decoders: MuPDF includes or links to standard codecs. It uses libjpeg for JPEG decoding, OpenJPEG for JPEG2000 (JPX) images, and jbig2dec for JBIG2 decoding (the MuPDF source tree includes jbig2dec). It also uses zlib for Flate streams. Additionally, MuPDF has support for less common formats: e.g. it lists a JPEG-XR decoder and even an HTML5 (Gumbo) parser in its third-party components – though these are rarely used in normal PDF rendering (JPEG-XR could be in some PDFs as an image format extension). For color management (ICC profiles in PDFs), MuPDF uses a fork of Little CMS (lcms2).
-   JavaScript: Uniquely, MuPDF does implement PDF JavaScript via a very small engine called MuJS. MuJS is a lightweight JS interpreter created by Artifex, designed to run Acrobat JS code in PDFs without the bloat of SpiderMonkey/V8. It supports enough of ECMAScript for forms. So, MuPDF and Sumatra PDF *do* execute PDF-embedded JavaScript (if the feature is enabled), using MuJS. This adds an attack surface, though MuJS being simpler might have fewer known bugs (and it’s less targeted than the bigger engines). Still, a malicious PDF could target flaws in MuJS or in how MuPDF’s JS interfaces with the document model.
-   Core Engine: MuPDF’s core is custom-built in C (with some parts in C++). It’s very fast and small, but fully capable of parsing PDF structures. It handles forms (AcroForm, not XFA), content streams, etc. Sumatra PDF basically delegates to MuPDF for all parsing and rendering. Because MuPDF is used in many mobile apps and viewers, it has been audited and fuzzed; numerous vulnerabilities in its image parsers and core were found in the past (e.g. memory issues in JBIG2 or in PDF object processing). Artifex regularly updates it. MuPDF also includes an XPS and eBook (EPUB) parser (not relevant to PDFs but part of the code base).
-   Historical Notes: Sumatra PDF originally could use either MuPDF or Poppler as backends; in recent years it exclusively uses MuPDF for PDF rendering. Older MuPDF lacked JS support (it was added later), so Sumatra historically did not run PDF JavaScript – but newer versions may, if MuJS is integrated (Sumatra’s settings allow disabling scripting for safety). Overall, MuPDF’s smaller footprint means no multimedia or fancy features (no Flash, no XFA). Its attack surface is mainly in font and image decoding and the core parsing logic, all of which have had vulnerabilities but generally fewer than Adobe’s giant codebase.
    

## PDFium (Chrome/Edge PDF Viewer)

PDFium is the open-source PDF engine used by Google Chrome and Microsoft Edge (Chromium-based). It originated from Foxit’s code donated to Google. PDFium is also available as a standalone library (used by other apps). Its components:

-   Font Engine: PDFium uses FreeType for font parsing/rendering, similar to Foxit’s usage. In fact, as of 2015, PDFium bundled a subset of FreeType (with Foxit’s patches). Chrome’s build might use the system FreeType on Linux or the bundled one on Windows. Either way, FreeType handles all embedded fonts, so vulnerabilities or fixes in FreeType directly affect PDFium. (Chrome isolates font rendering in an sandboxed utility process, which helps mitigate risk from a malicious font exploit.)
-   Image Decoders: PDFium relies on a set of third-party libs for images, much like Poppler/Foxit. It includes libjpeg for JPEG, OpenJPEG for JPEG2000 (JPXDecode), jbig2dec (or an equivalent) for JBIG2, and zlib for Flate streams. These are compiled into the PDFium library (or linked). For color profiles, PDFium can use LittleCMS if needed (there are references to lcms in build configs). Because PDFium is used in Chrome, it prefers to use Chrome’s centralized versions of these libraries to avoid duplication. Notably, PDFium in Chromium disables some features like XFA by default (to reduce attack surface), so the JPEG2000, JBIG2, etc. support is present but tightly sandboxed (Chrome’s PDF renderer runs in a locked-down sandbox).
-   JavaScript: PDFium has *optional* support for JavaScript. It can be built with V8 engine integration (there is a build of PDFium that includes V8 to execute Acrobat JS for form actions). However, Chrome/Edge’s default PDF viewer does not enable PDF JavaScript execution – for security, they leave it off (thus most users of Chrome’s PDF cannot be attacked via PDF-embedded JS). If an application uses PDFium outside of Chrome, it could choose to enable JS by linking V8. (For example, certain PDF SDKs based on PDFium might enable it, or other Chromium-based products might in the future.) But broadly, in browsers PDFium = no JS. This significantly cuts down the exploit surface; attackers focus on fonts/images instead.
-   Core and Forms: PDFium implements all core PDF parsing (object streams, rendering via Skia graphics in Chrome, etc.). It supports AcroForms (form filling) but not full XFA (Chrome doesn’t support XFA documents). The lack of XFA and JS means many complex malicious PDFs won’t fully run in Chrome’s viewer, which is a deliberate security decision. PDFium’s core is heavily fuzz-tested by Google; nonetheless, bugs have been found (Chrome’s Project Zero once found dozens of PDFium bugs by fuzzing). Each such bug requires a Chrome update. One example area is the JPEG2000 decoder – it has had memory safety issues that Google patched. Chrome’s sandbox mitigates some of this.
-   Version changes: Early PDFium (2014–2016) was still catching up with features; by now it’s quite complete. If we consider Edge Legacy (pre-Chromium) – it had a different PDF engine (built by Microsoft, with probably Windows code libraries) which supported fewer features and had some bugs. Now Edge uses PDFium like Chrome. Safari’s viewer is separate (see below). Overall, PDFium’s component usage aligns with Foxit’s, given the shared origin: FreeType, libjpeg, openjpeg, zlib, etc., all continuously updated in Chromium.
    

## PDF.js (Firefox’s PDF Viewer)

PDF.js is Mozilla’s JavaScript-based PDF viewer (used in Firefox and available as a library). It’s quite different in architecture – written in JavaScript, running in the browser environment. Its handling of components:

-   Font Handling: PDF.js cannot use native C libraries directly; instead it either leverages the browser or implements features in JS. For fonts, PDF.js will extract embedded font files from the PDF and use the browser’s font rendering to display text. It does this by *dynamically converting fonts* to OpenType and injecting them via CSS `@font-face` or the Canvas API. Internally, PDF.js has code (or uses the opentype.js library) to parse font data (TrueType tables, CFF, etc.) in JavaScript, so it can subset or sanitize them before defining the font in the DOM. This means the heavy lifting is often deferred to the browser’s font engine (e.g. the OS’s font renderer, which is well-tested). Nevertheless, any flaw in PDF.js’s JS font parsing could be an issue, though it’s mostly parsing data, not executing bytecode (the actual hinting bytecode in fonts is likely ignored or handled by the OS).
-   Image Decoding: Wherever possible, PDF.js offloads to the browser. Standard images like JPEG: PDF.js can create a Blob URL from the raw JPEG stream and draw it to a `<canvas>` or `<img>` – the browser’s native decoder (often using libjpeg or OS codecs) will decode it safely. For JPEG2000 and JBIG2, browsers do *not* support those formats natively, so PDF.js has to handle them. Indeed, PDF.js includes a JPX decoder built on OpenJPEG compiled to WebAssembly. It similarly has a JBIG2 decoder implemented in JavaScript (there is code in PDF.js project for JBIG2; likely a port of jbig2dec or a custom decoder in JS). These decoders in JS/WASM are part of PDF.js’s code base and are used to render those image types. Any vulnerabilities in OpenJPEG or jbig2dec would theoretically carry over to these versions, but exploiting them is more complex in JS/WASM (no direct memory corruption in the JS engine; though logic bugs could hang or overflow arrays). Other filters like Flate (zlib): PDF.js uses a JavaScript zlib (for example the *pako* library) to decompress Flate streams. Similarly, ASCII85 and LZW are handled in JS.
-   JavaScript in PDF: Firefox’s PDF.js does *not* execute embedded PDF JavaScript. This is a conscious choice for security. The PDF JavaScript specification is large and implementing it would require embedding a JS engine (which the browser already has, but the PDF API integration is non-trivial). Instead, PDF.js focuses on static rendering and simple form filling. (There was a long-standing issue about JS support which was closed with “won’t implement due to security”.) So, any `<script>` embedded in a PDF is ignored by PDF.js. This means Firefox’s viewer is immune to attacks that rely on Acrobat JavaScript execution (which historically is a big chunk of PDF exploits).
-   Core Parsing: PDF.js itself is essentially the PDF parser implemented in JavaScript. It reads the PDF file bytes, parses the structure (cross-references, objects, streams) in JS, and then draws output to HTML5 Canvas or SVG. The “core” of PDF.js is safe from buffer overflow by design (managed memory in JS), but logic bugs can still occur (e.g. Regular expression DoS in parser, or extremely large objects causing performance issues). The rendering runs with the privileges of the webpage (subject to web sandbox, so it can’t access local files arbitrarily). In terms of libraries, PDF.js doesn’t use external native libs – everything is either done in JS or via browser APIs. For example, text rendering uses the browser’s Canvas text APIs or font rendering via CSS. The image drawing uses Canvas 2D.
-   Notable Differences: Since PDF.js is updated with Firefox, it tends to stay current. In older versions (circa 2013 when PDF.js was new), performance was a concern and it lacked some features like forms. Over time it gained form filling and better support for images (adding JPEG2000, etc.). But it still omits risky features (no XFA, no JS). Attackers targeting Firefox’s PDF viewer would likely try to exploit the JS implementation itself (logic flaws that might allow breaking out of the sandbox or crashing the content process). There have been far fewer real-world malware samples targeting PDF.js, likely because of its restrictive feature set and the difficulty of memory attacks on a JS engine that’s already hardened by the browser environment.

## Apple Preview (macOS PDFKit)

Apple’s Preview app (and any macOS/iOS app using PDFKit framework) relies on Apple’s native PDF renderer, built into CoreGraphics. This is a closed-source engine, but we know it uses macOS system libraries:

-   Font Handling: macOS uses Core Text and other system font services to render fonts. PDFKit will hand embedded fonts to CoreGraphics/CoreText, which likely utilizes Apple’s font engines (not FreeType, as Apple has its own). In the past, Apple’s font engine (ATS/CT) has had vulnerabilities, but in context of PDF, the fonts are user-space so exploits would target CoreText (which is hardened and runs in the app’s process). There were cases where an embedded font in a PDF triggered an iOS exploit, but more commonly image decoders were the target (see below).
-   Image Decoders: Apple’s PDF engine delegates image decoding to ImageIO, the macOS/iOS image framework. ImageIO supports JPEG, PNG, TIFF, JPEG2000 (using Apple’s implementation of JPEG2000, which might be based on OpenJPEG or their own code), and possibly JBIG2. Notably, *Apple’s JBIG2 decoder in CoreGraphics was exploited by the NSO “FORCEDENTRY” exploit*: an integer overflow in JBIG2 processing (CoreGraphics) allowed remote code execution via a malicious PDF sent to iMessage. This shows that Preview/iOS PDF rendering did include a JBIG2 library (likely Apple’s custom or a licensed one). Apple patched this (CVE-2021-30860). Similarly, Apple’s JPEG2000 (within ImageIO) has had security fixes. Apple tends to use its own libs (but they could incorporate open-source under the hood – for instance, ImageIO’s JP2 might use OpenJPEG or JasPer). All such decoding happens in the context of the calling app (Preview or an iMessage process), though on iOS it’s sandboxed.
-   JavaScript and Multimedia: Apple’s PDFKit does not support PDF-embedded JavaScript at all (no form scripts run in Preview). It also does not support XFA forms. Apple’s philosophy is to handle PDF as a static document format, so interactive/scripted PDFs made for Acrobat simply won’t have that interactivity in Preview. This eliminates script-based attacks. For multimedia, Preview can play embedded videos if they’re in supported formats (QuickTime), but it never supported Flash. The attack surface here is minimal compared to Adobe.
-   Core Parsing: The PDF parsing code is within CoreGraphics (CGPDFDocument API). Apple’s implementation handles the structure and rendering using Quartz 2D. It is optimized and uses hardware where possible. There have been vulnerabilities in this core (e.g. corrupt object streams causing memory issues), but less frequently reported than Adobe’s. One reason is that the complexity (JS, XFA, etc.) is stripped out. That said, Apple’s engine must still handle fonts and images where most of the risk lies.
-   Differences over time: Apple’s PDF engine has been relatively stable. Major changes were integrating sandboxing (Preview on macOS runs with normal user rights, but iOS’s PDF rendering runs inside the BlastDoor sandbox for iMessage now). Older macOS (10+ years ago) might not have had JBIG2 support due to patent concerns, but Apple eventually added it, which led to the aforementioned exploit. After 2021, Apple hardened PDF handling significantly (BlastDoor on iOS specifically to handle parsing of untrusted PDFs/images in messages). In summary, Apple’s component usage is mostly in-house: CoreText for fonts, ImageIO for images (including JP2K, JBIG2), no JS, no XFA. The absence of user-run scripts and the presence of OS-level sandboxing (on iOS) means the attack surface, while still present (as Pegasus showed), is more narrowly focused on the image/font decoding.
    
## Other Notable PDF Readers

-   Nitro PDF (Windows): A popular alternative PDF viewer/editor. It’s closed-source, but likely uses a mix of open-source libraries similar to others (possibly FreeType for fonts, maybe MuPDF or Poppler code under the hood, given some PDF libraries are reused in industry). Nitro has had similar font and image vulnerabilities reported in its advisories. Without specifics, one can assume Nitro’s components mirror the common choices (FreeType, libjpeg, OpenJPEG, etc.).
-   PDF-XChange Editor/Viewer (Windows): Another proprietary reader. Likely uses its own engine or licensed one. Some reports suggest it may use *MuPDF* internally for rendering, which would imply the same third-party libs (FreeType, etc.) apply.
-   Ghostscript: Not a viewer UI, but often used to render or convert PDFs (on servers or via command line). It has its own PDF interpreter, and uses many of the same libraries: FreeType for fonts, a built-in PostScript-like imaging model, jbig2dec (which Ghostscript developers maintain) for JBIG2, etc. Ghostscript’s vulnerabilities (numerous in its parsing of PDF/PS) can affect any system that processes untrusted PDFs headlessly (e.g. printers or file converters). It’s worth noting since it’s a widely deployed PDF processor.

## References and Sources

The above information is compiled from documentation, security advisories, and project sources. Key references include Adobe/BlackHat papers outlining Acrobat’s internal components, Foxit security advisories on their JPEG2000/JBIG2 decoder, Exodus Intelligence analysis confirming Adobe’s use of SpiderMonkey JS, SEC Consult’s report on Foxit’s use of V8, and open-source project docs for Poppler, MuPDF, and PDF.js which detail their library dependencies and capabilities. These sources (and others cited in-line) provide a comprehensive view of each reader’s “building blocks” and how they have evolved. Each reader’s attack surface is a combination of these underlying components – making it clear why attackers craft PDFs to target specific weaknesses in fonts, images, or script engines of whichever viewer their victim is likely using.


