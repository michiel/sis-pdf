# Visualisation and Metadata Uplift Plan: Event Graph, Chains, and Analyst Workflow

Date: 2026-02-20
Status: Proposed
Owner: GUI (`sis-pdf-gui`), core models (`sis-pdf-core`), CLI (`sis-pdf`)

## Goals

1. Make exploit chains immediately readable by analysts without mental reconstruction from flat findings.
2. Expose the data richness that already exists in the event graph model in visual form.
3. Add metadata fields to `ExploitChain` and `Finding` that improve triage, severity composition, and downstream tooling.
4. Provide workflow ergonomics that reduce analyst time on corpus-scale investigations.

## Current state summary

- `ExploitChain` (`chain.rs`): id, group, trigger/action/payload (Option<String>), findings, score, reasons, path, nodes, edges, notes (HashMap<String,String>). No stage vocabulary, no reader risk, no completeness, no narrative.
- Chain panel (`panels/chains.rs`): flat list with score, text path, trigger/action/payload labels, horizontal flow diagram (Trigger → Action → Payload), finding links. No completeness indicator, no reader divergence, no stage alignment.
- Graph panel (`panels/graph.rs`): Fruchterman-Reingold force-directed layout only. `GraphViewMode` has two variants: `Structure` and `Event`. Chain overlay exists (`chain_overlay`, `build_chain_overlay`) but is binary (on/off, equal visual weight). No staged layout, no critical path highlight, no MITRE panel.
- `GraphViewerState`: pan, zoom, hovered/selected node, type/trigger/reader/depth filters, chain filter/overlay. No DAG layout mode, no critical-path state.
- `GraphData` (`graph_data.rs`): `GraphNode` carries object_ref, obj_type, label, roles, confidence, position. `GraphEdge` carries from/to index, suspicious flag, edge_kind, provenance, metadata.
- `EventGraph` (`event_graph.rs`): `EventNode` carries MITRE techniques and kind (Object/Event/Outcome/Collapse). MITRE data is present but never surfaced in any panel.
- `Taint` (`taint.rs`): `flagged: bool`, `reasons: Vec<String>`. No source object refs, no propagation edges.
- `Finding` model: `evidence: Vec<EvidenceSpan>` carries `offset: u64` and `length: u32`. EvidenceSpan byte offsets exist but there is no cross-panel jump from a finding to the hex viewer at that offset.
- `ReaderImpact` on Finding: `profile: ReaderProfile` (Acrobat/Pdfium/Preview), `severity`, `impact`. Present per finding, not aggregated per chain.

## Scope

In scope:
- `ExploitChain` data model enrichment: completeness, reader risk, narrative, per-finding criticality, blocker fields.
- `Taint` model extension: source object refs and propagation edges.
- GUI: staged DAG layout mode, critical path highlight, chain completeness bar, reader risk chips, scatter fan-in rendering, MITRE technique panel, revision timeline panel, taint propagation overlay.
- GUI workflow: evidence-span-to-hex-offset jump navigation, object tree severity heatmap, analyst annotation sidecar.
- CLI: `sis diff` command for finding-level diffing across two scan outputs.

Out of scope (this plan):
- New detector logic (covered in `plans/20260219-detection-uplift.md`).
- Changes to `EventGraph` node/edge model beyond adding taint propagation edges.
- WASM worker protocol changes.

---

## Phase 1: Data model enrichment

These changes are prerequisites for all visualisation work. They add no GUI code and can land independently.

### V1: ExploitChain completeness and stage fields

**Files:** `crates/sis-pdf-core/src/chain.rs`, `crates/sis-pdf-core/src/chain_synth.rs`

**Changes to `ExploitChain` in `chain.rs`:**

Add fields after `edges`:

```rust
/// Stages confirmed by findings with Probable or higher confidence.
/// Values from the CQ1 vocabulary: "input", "decode", "render", "execute", "egress".
#[serde(default)]
pub confirmed_stages: Vec<String>,

/// Stages inferred by chain synthesis with Tentative or lower confidence.
#[serde(default)]
pub inferred_stages: Vec<String>,

/// Ratio of confirmed stages to total expected stages (0.0–1.0).
#[serde(default)]
pub chain_completeness: f64,

/// Aggregated per-reader risk derived from constituent finding reader_impacts.
/// Key is ReaderProfile::as_str() ("acrobat", "pdfium", "preview").
/// Value is the serialised Severity string ("Critical", "High", etc.).
#[serde(default)]
pub reader_risk: std::collections::HashMap<String, String>,

/// Template-composed natural language summary of the chain.
#[serde(default)]
pub narrative: String,
```

**Changes to `chain_synth.rs`:**

In `finalize_chain`, after `render_path` and before `score_chain`:

1. Collect `chain.stage` values from constituent finding `meta` maps.
   - Finding with `chain.stage` in meta and `confidence >= Probable` → add to `confirmed_stages`.
   - Finding with `chain.stage` in meta and `confidence < Probable` → add to `inferred_stages`.
   - `chain_completeness = confirmed_stages.len() as f64 / 5.0` (5 expected stages).

2. Aggregate `reader_risk` from `findings_by_id` → `finding.reader_impacts`:
   - For each `ReaderImpact` in each constituent finding, take the max severity per `profile.as_str()`.
   - Serialise as `severity.to_string()`.

3. Compose `narrative` via `compose_chain_narrative(chain)` (new function in `chain_render.rs` — see V9).

**New function `compose_chain_narrative`** (see V9 below).

Acceptance criteria:
- A chain with three findings carrying `chain.stage=input`, `chain.stage=execute`, `chain.stage=egress` (all Probable+) has `confirmed_stages = ["input", "execute", "egress"]`, `chain_completeness = 0.6`.
- A chain with all five stages confirmed has `chain_completeness = 1.0`.
- `reader_risk["acrobat"] = "Critical"` when any constituent finding has a Critical Acrobat reader impact.
- Existing `chain_grouping` tests still pass.

### V2: ExploitChain per-finding criticality and blocker fields

**Files:** `crates/sis-pdf-core/src/chain.rs`, `crates/sis-pdf-core/src/chain_synth.rs`

**Changes to `ExploitChain`:**

```rust
/// Per finding-id: how much the chain score drops if that finding is removed (0.0–1.0).
/// Higher = more critical to this chain's exploitability.
#[serde(default)]
pub finding_criticality: std::collections::HashMap<String, f64>,

/// Mitigations confirmed present in the document (from exploit.blockers meta on findings).
#[serde(default)]
pub active_blockers: Vec<String>,

/// Mitigations absent that would prevent exploitation (from exploit.preconditions meta).
#[serde(default)]
pub missing_blockers: Vec<String>,
```

**Population in `finalize_chain`:**

- `active_blockers`: collect unique values of `exploit.blockers` meta across constituent findings, split by `,`.
- `missing_blockers`: collect unique values of `exploit.preconditions` meta, cross-reference against `active_blockers`; anything in preconditions not met = missing blocker.
- `finding_criticality`: for each finding id in `chain.findings`, compute `baseline_score - score_without(finding)`:
  - `score_without(fid)` = `score_chain` run on the notes rebuilt from all findings except `fid`.
  - Store delta (clamped 0.0–1.0).
  - This is O(n²) in findings per chain. Given chain size ≤ 20 findings in practice, this is acceptable. Add a guard: skip if `chain.findings.len() > 30`.

Acceptance criteria:
- Removing the sole trigger finding from a chain produces a criticality close to the score delta between a chain with and without an auto-trigger.
- `active_blockers` and `missing_blockers` are populated correctly when findings carry `exploit.blockers` and `exploit.preconditions` meta.

### V3: Taint source and propagation extension

**File:** `crates/sis-pdf-core/src/taint.rs`

**Changes to `Taint`:**

```rust
pub struct Taint {
    pub flagged: bool,
    pub reasons: Vec<String>,
    /// PDF object refs that are sources of taint (JS payload, embedded file, etc.).
    pub taint_sources: Vec<(u32, u16)>,
    /// Directed propagation edges: (source_obj, influenced_obj).
    /// Derived from action chain and reference edges in taint-flagging findings.
    pub taint_propagation: Vec<((u32, u16), (u32, u16))>,
}
```

**Population in `taint_from_findings`:**

- For each taint-flagging finding, extract `finding.objects` (parsed as `(u32, u16)` from "obj N M" strings) and add to `taint_sources`.
- For action-chain findings (`action_chain_complex`, `launch_action_present`): use `finding.positions` to infer propagation edges between consecutive positions (position[0] → position[1], etc.).
- Dedup both lists.

Acceptance criteria:
- A scan with a `js_present` finding on obj 6 0 produces `taint_sources = [(6, 0)]`.
- Propagation edges are non-empty when action chain findings are present.

---

## Phase 2: Core visualisation improvements

These are GUI changes in `sis-pdf-gui`. They depend on Phase 1 data being present.

### V4: Staged DAG layout mode

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/graph_layout.rs` (new `graph_layout_dag.rs`)

**Changes to `GraphViewMode` in `panels/graph.rs`:**

```rust
pub enum GraphViewMode {
    Structure,
    Event,
    StagedDag, // new
}
```

**New `graph_layout_dag.rs`:**

```rust
/// Column assignment for staged DAG layout.
/// Maps chain.stage values and node roles to column index 0–4.
pub fn stage_column(node: &GraphNode) -> usize {
    // Check roles vec for stage markers set during from_event_graph conversion.
    // "input" -> 0, "decode" -> 1, "render" -> 2, "execute" -> 3, "egress" -> 4
    // Outcome nodes with OutcomeType::NetworkEgress/FormSubmission -> 4
    // Outcome nodes with OutcomeType::CodeExecution -> 3
    // Event nodes with TriggerClass::Automatic/Hidden -> 0
    // Default: 2 (render/middle)
}

/// Assign positions for a staged DAG layout.
/// Column width = area_w / 5.0. Nodes within a column are distributed vertically.
pub fn apply_dag_layout(graph: &mut GraphData) {
    let area_w = 800.0f64;
    let area_h = 600.0f64;
    let col_w = area_w / 5.0;
    // Group nodes by column, assign y positions evenly within column.
    // Back-edges (egress → input) rendered as curved arcs; handled at draw time by
    // checking that edge from_col > to_col.
}
```

**Changes to `GraphViewerState`:**

Add `dag_layout_dirty: bool` — set when switching to StagedDag mode to trigger re-layout.

**Changes to `show_toolbar` in `panels/graph.rs`:**

Add a third layout mode button: `[Force-directed] [Event] [Staged DAG]`.

**Rendering changes for StagedDag mode:**

In the draw loop, when `mode == StagedDag`:
- Draw 5 vertical lane separators (light grey, 1px) at column boundaries.
- Draw column header labels (INPUT / DECODE / RENDER / EXECUTE / EGRESS) at top.
- Render back-edges (from_col > to_col) as curved Bézier arcs drawn above the lane headers.
- All other rendering (node colours, labels, tooltips) unchanged.

Acceptance criteria:
- Switching to Staged DAG mode places event nodes in the leftmost columns and outcome nodes in the rightmost.
- Back-edges are visually distinct from forward edges.
- All existing node colours and tooltips are preserved.

### V5: Critical path highlight

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/graph_data.rs`

**Changes to `GraphViewerState`:**

```rust
/// Set of (from_idx, to_idx) edge pairs on the highest-scoring path.
pub critical_path_edges: std::collections::HashSet<(usize, usize)>,
/// Node indices on the critical path.
pub critical_path_nodes: std::collections::HashSet<usize>,
/// Whether to show only the critical path (dims non-path nodes).
pub show_critical_path: bool,
```

**New function `compute_critical_path(graph: &GraphData, event_graph: &EventGraph) -> (HashSet<(usize, usize)>, HashSet<usize>)`:**

- Forward BFS from all `TriggerClass::Automatic` event nodes.
- Edge weight = confidence of the `to` node (use `GraphNode::confidence.unwrap_or(0.5)`).
- Path score = product of edge weights.
- Return the (from_idx, to_idx) pairs on the maximum-weight path from any trigger to any Outcome node.
- Call after graph is built in `build_graph`.

**Rendering changes:**

When `show_critical_path`:
- Critical path edges: stroke width 3.0 px (vs default 1.0), colour `Color32::from_rgb(255, 140, 0)`.
- Critical path nodes: full opacity, stroke width 2.0.
- All other nodes and edges: `Color32` alpha reduced to 50 (≈20% opacity). Achieved by blending with background colour.
- Toolbar toggle: `[Critical path]` button beside existing controls.

Acceptance criteria:
- A document with a single OpenAction → JavaScript → NetworkEgress chain shows the three nodes and two edges highlighted.
- Non-path nodes are visibly dimmed.
- Toggle restores full rendering.

### V6: Chain completeness bar in chain panel

**File:** `crates/sis-pdf-gui/src/panels/chains.rs`

**Changes to `ChainDisplay`:**

```rust
struct ChainDisplay {
    // ... existing fields ...
    confirmed_stages: Vec<String>,
    inferred_stages: Vec<String>,
    chain_completeness: f64,
    reader_risk: std::collections::HashMap<String, String>,
    narrative: String,
}
```

Populate from `chain.confirmed_stages`, `chain.inferred_stages`, `chain.chain_completeness`, `chain.reader_risk`, `chain.narrative`.

**New function `show_completeness_bar(ui, confirmed, inferred)`:**

```
ui.horizontal(|ui| {
    for stage in &["INPUT", "DECODE", "RENDER", "EXECUTE", "EGRESS"] {
        let lower = stage.to_lowercase();
        let colour = if confirmed.contains(&lower) { Color32::GREEN }
                     else if inferred.contains(&lower) { Color32::YELLOW }
                     else { Color32::DARK_GRAY };
        ui.colored_label(colour, *stage);
        ui.label(" ");
    }
    ui.label(format!("{:.0}% complete", chain_completeness * 100.0));
});
```

**New function `show_reader_risk_chips(ui, reader_risk)`:**

```
ui.horizontal(|ui| {
    for profile in &["acrobat", "pdfium", "preview"] {
        if let Some(sev) = reader_risk.get(*profile) {
            let colour = severity_colour(sev);  // reuse existing severity_colour logic
            ui.colored_label(colour, format!("{}: {}", profile, sev));
            ui.add_space(4.0);
        }
    }
});
```

Place completeness bar and reader risk chips below the existing flow diagram in each chain group.

**Add narrative display:**

Below reader risk chips, render `chain.narrative` as a wrapped label when non-empty.

Acceptance criteria:
- A chain with three confirmed stages shows three green labels and two grey labels.
- Inferred stages render in yellow.
- Reader risk chips show correct colours per severity.

### V7: Evidence span to hex viewer jump navigation

**Files:** `crates/sis-pdf-gui/src/panels/detail.rs`, `crates/sis-pdf-gui/src/app.rs`

**Current state:** `EvidenceSpan` has `offset: u64` and `length: u32`. The finding detail panel renders evidence spans as plain text. The hex viewer exists (`panels/hex_viewer.rs`) with `HexViewState` in `SisApp`.

**Changes to `panels/detail.rs`:**

In the evidence span rendering section, replace plain text with a clickable link:

```rust
for span in &finding.evidence {
    let label = format!("offset 0x{:x} ({} bytes)", span.offset, span.length);
    if ui.link(&label).clicked() {
        app.hex_view.jump_to = Some(span.offset);
        app.show_hex = true;
    }
}
```

**Changes to `HexViewState` in `app.rs`:**

Add `jump_to: Option<u64>` field. In `panels/hex_viewer.rs`, when `jump_to` is set: scroll the hex view to show that offset, highlight the `length` bytes in a distinct colour, then clear `jump_to`.

Acceptance criteria:
- Clicking an evidence span offset in the finding detail panel opens the hex viewer at that byte offset.
- The relevant bytes are visually highlighted.
- The jump works for both `EvidenceSource::File` and `EvidenceSource::Decoded` spans (with a label distinguishing them).

### V8: Object tree severity heatmap

**Files:** `crates/sis-pdf-gui/src/panels/objects.rs`, `crates/sis-pdf-gui/src/analysis.rs`

**Changes to `AnalysisResult` in `analysis.rs`:**

Add pre-computed index after scan:

```rust
/// Map from (obj, gen) to (max_severity, finding_count) for the object heatmap.
pub object_severity_index: std::collections::HashMap<(u32, u16), (Severity, usize)>,
```

Populate during result construction by iterating `report.findings` and extracting `finding.objects` → parse as `(u32, u16)` → accumulate max severity and count.

**Changes to `panels/objects.rs`:**

In the object list row rendering, add a coloured severity dot and count badge before the object label:

```rust
if let Some((max_sev, count)) = result.object_severity_index.get(&(obj, gen)) {
    let colour = severity_colour_for(max_sev);
    // Draw filled circle (radius 5.0) in severity colour
    // Draw count badge: small grey label "(N)"
}
```

Acceptance criteria:
- Objects with findings show a coloured dot (red for Critical/High, orange for Medium, grey for Low/Info).
- Objects with no findings show no dot.
- Finding count badge is accurate.

---

## Phase 3: New panels

### V9: Per-chain narrative composition

**File:** `crates/sis-pdf-core/src/chain_render.rs`

**New function:**

```rust
pub fn compose_chain_narrative(chain: &ExploitChain) -> String
```

Template-driven composition from structured chain fields. No external dependencies.

Template skeleton:

```
"{trigger_desc} {action_desc}{scatter_clause}{payload_clause}.{precondition_clause}{blocker_clause}"
```

Field mapping:
- `trigger_desc`: derived from `notes["trigger.label"]` or `chain.trigger` →
  - `open_action_present` → "An automatic document-open action"
  - `aa_event_present` → "A field event action"
  - default → "An action"
- `action_desc`: `notes["action.type"]` →
  - `JavaScript` → "executes JavaScript"
  - `Launch` → "launches an external process"
  - `SubmitForm` → "submits form data"
  - `URI` → "opens a URI"
  - default → "triggers an action"
- `scatter_clause`: if `notes["scatter.fragment_count"]` present → ` assembling a payload from {n} document fragments`
- `payload_clause`: from `notes["payload.type"]` and `notes["payload.summary"]`
- `precondition_clause`: if `chain.missing_blockers` non-empty → ` Exploitation requires: {list}.`
- `blocker_clause`: if `chain.active_blockers` non-empty → ` Mitigated by: {list}.`

Call `compose_chain_narrative` in `finalize_chain` (after score) and assign to `chain.narrative`.

Acceptance criteria:
- A chain with trigger=open_action_present, action=js_present, payload=javascript produces a non-empty narrative sentence.
- A chain with `scatter.fragment_count=3` includes the fragment count in the narrative.
- Narrative is stable across identical inputs (deterministic).

### V10: MITRE ATT&CK technique panel

**Files:** new `crates/sis-pdf-gui/src/panels/mitre.rs`, `crates/sis-pdf-gui/src/panels/mod.rs`, `crates/sis-pdf-gui/src/app.rs`

**Data source:** `EventGraph::nodes` where `node.mitre_techniques` is non-empty.

**`SisApp` additions:**

```rust
pub show_mitre: bool,
/// Set of MITRE technique IDs to highlight in the graph.
pub mitre_highlight: Option<std::collections::HashSet<String>>,
```

**`panels/mitre.rs` implementation:**

1. Collect all (technique_id, Vec<EventNodeId>) pairs from the event graph, sorted by technique ID.
2. Render as a scrollable list:
   ```
   [T1204.002] User Execution: Malicious File  (3 nodes)
   [T1059.007] JavaScript                       (1 node)
   ```
3. Clicking a technique:
   - Sets `app.mitre_highlight = Some(set_of_node_ids_for_technique)`.
   - Highlights those nodes in the graph panel (uses same dimming mechanism as critical path).

**Graph panel rendering change:**

When `app.mitre_highlight` is set, nodes whose `EventNodeId` is in the set render with a purple border ring (2px, `Color32::from_rgb(180, 80, 220)`). All others dimmed to 50% opacity.

Acceptance criteria:
- Panel lists all MITRE techniques present in the event graph with accurate node counts.
- Clicking a technique highlights the correct nodes in the graph.
- Closing the panel clears `mitre_highlight`.

### V11: Revision timeline panel

**Files:** new `crates/sis-pdf-gui/src/panels/revision.rs`, `crates/sis-pdf-gui/src/panels/mod.rs`

**Data source:** Findings with kinds `incremental_update_chain`, `revision_forensics_present`, `shadow_hide_attack`, `shadow_replace_attack`, `object_id_shadowing`. These findings carry object refs and `meta` fields recording revision numbers.

**Panel layout:**

Horizontal scrollable timeline. Each revision is a vertical column:

```
Rev 1 (baseline)     Rev 2 (+42 objs)     Rev 3 (+7 objs, post-cert)
[baseline]           [obj 6 0 added]      [obj 41-47 added]
                     [obj 9 0 added]      [obj 9 0 shadowed by obj 47 0]
```

- Revisions extracted from `meta["revision.index"]` on findings, deduplicated and sorted.
- Shadow attack objects highlighted with a `Color32::RED` border and a "post-cert" label when `meta["revision.post_cert"] == "true"`.
- Clicking a revision column filters the event graph: `app.graph_state.event_trigger_filter` set to show only objects introduced in that revision (requires the event graph to carry revision provenance on nodes via `EdgeMetadata`).

**Note on filtering:** Full revision-based graph filtering requires revision metadata on `EventNode` objects. If that metadata is absent, the panel is rendered read-only (click shows a tooltip listing affected objects but does not filter the graph). This is a graceful degradation.

Acceptance criteria:
- Panel renders without error when no revision findings are present (shows "No incremental revisions detected").
- Panel shows correct revision counts when revision findings are present.
- Shadow attack objects are visually distinct.

### V12: Taint propagation overlay

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/app.rs`

**Prerequisite:** V3 (Taint source and propagation extension).

**`GraphViewerState` addition:**

```rust
/// Whether to show taint propagation as an overlay.
pub show_taint_overlay: bool,
/// Pre-computed taint edge set: (from_idx, to_idx) derived from Taint::taint_propagation.
pub taint_edges: Vec<(usize, usize)>,
/// Node indices that are taint sources.
pub taint_source_nodes: std::collections::HashSet<usize>,
```

**Population:**

After graph is built, resolve `Taint::taint_sources` and `Taint::taint_propagation` through `GraphData::node_index` to produce `taint_source_nodes` and `taint_edges`.

**Rendering:**

When `show_taint_overlay`:
- Taint source nodes: red border ring (3px, `Color32::RED`).
- Taint propagation edges: rendered as dashed strokes (approximate with short line segments at 6px intervals) in `Color32::from_rgb(200, 60, 60)`.
- Non-taint nodes and edges: rendered at 40% opacity.
- Toolbar toggle: `[Taint]` button.

Acceptance criteria:
- Taint overlay shows source nodes and propagation edges when taint is present.
- Overlay is independent of the critical path and chain overlays (each can be toggled independently).
- When `Taint::flagged == false`, toggle button is disabled (greyed out).

---

## Phase 4: Workflow ergonomics

### V13: Analyst annotation sidecar

**Files:** new `crates/sis-pdf-gui/src/annotations.rs`, changes to `app.rs`, `panels/findings.rs`, `panels/chains.rs`

**Data model (`annotations.rs`):**

```rust
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum TriageState {
    Pending,
    Confirmed,
    FalsePositive,
    Mitigated,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Annotation {
    pub finding_id: String,
    pub note: String,
    pub triage_state: TriageState,
    pub timestamp_unix: u64,
}

#[derive(Debug, Default, serde::Serialize, serde::Deserialize)]
pub struct AnnotationStore {
    /// SHA-256 of the analysed PDF (hex string). Guards against applying annotations
    /// from a different document.
    pub document_sha256: String,
    pub annotations: std::collections::HashMap<String, Annotation>,
}

impl AnnotationStore {
    /// Load from a `.sis-notes.json` sidecar file beside the PDF path.
    pub fn load(pdf_path: &std::path::Path) -> Self { ... }
    /// Save to the sidecar file.
    pub fn save(&self, pdf_path: &std::path::Path) -> std::io::Result<()> { ... }
    /// Path convention: `{pdf_path}.sis-notes.json`
    pub fn sidecar_path(pdf_path: &std::path::Path) -> std::path::PathBuf { ... }
}
```

**`SisApp` additions:**

```rust
pub annotations: crate::annotations::AnnotationStore,
pub annotation_edit_finding: Option<String>, // finding_id being annotated
```

**`panels/findings.rs` changes:**

In each finding row, add an annotation icon column (a coloured circle):
- No annotation: empty circle, grey.
- `Confirmed`: filled green circle.
- `FalsePositive`: filled red circle.
- `Mitigated`: filled blue circle.
- `Pending`: filled yellow circle.
- Clicking the icon opens an inline annotation editor (egui popup with: note text area, triage state selector, save/clear buttons).

**`panels/chains.rs` changes:**

Show triage state aggregate for a chain: if all constituent findings are `FalsePositive` → mark chain as `[FP]`. If all are `Mitigated` → mark chain as `[OK]`.

**Persistence:** Annotations are saved to the sidecar on every change (call `store.save(pdf_path)`). If `pdf_path` is not available (WASM drag-drop), annotations are kept in memory only and a notice is shown.

Acceptance criteria:
- An annotation added to a finding persists across app restarts when a file path is available.
- The sidecar is rejected (and a warning shown) if `document_sha256` does not match the loaded document.
- Findings with annotations show the correct triage colour.

### V14: `sis diff` command

**Files:** new `crates/sis-pdf/src/commands/diff.rs`, `crates/sis-pdf/src/commands/mod.rs`

**Command interface:**

```
sis diff <baseline.jsonl> <comparison.jsonl> [--format text|json]
```

Accepts two scan output files (JSONL, one finding per line or one report per line).

**Output (text):**

```
+ NEW   [High/Strong]   js_present             (obj 6 0)
+ NEW   [Critical/Certain] launch_action_present (obj 9 0)
- GONE  [Medium/Probable] uri_content_analysis   (obj 3 0)
~ CHANGED js_sandbox_exec  Medium/Strong -> High/Strong
```

**Output (JSON):**

```json
{
  "new_findings": [...],
  "removed_findings": [...],
  "changed_findings": [
    { "id": "...", "kind": "...", "baseline": { "severity": "...", "confidence": "..." },
      "comparison": { "severity": "...", "confidence": "..." } }
  ]
}
```

**Matching logic:** Findings are matched by `kind` + `objects` combination (not by `id`, which changes across scans). A finding is "changed" if kind+objects match but severity or confidence differs.

**Exit codes:** 0 = no new high/critical findings; 1 = new high/critical findings present. Useful for CI integration.

Acceptance criteria:
- `sis diff a.jsonl b.jsonl` correctly identifies new, removed, and changed findings.
- `--format json` produces machine-parseable output.
- Exit code 1 when new Critical findings are present.

---

## Delivery sequence

1. **V3** (Taint model extension) — no GUI impact, low risk. Run `cargo test -p sis-pdf-core`.
2. **V1** (ExploitChain completeness + reader risk) — data model only. Run `cargo test -p sis-pdf-core --test chain_grouping`.
3. **V2** (ExploitChain criticality + blockers) — data model only, same test suite.
4. **V7** (Evidence span → hex viewer jump) — small GUI change, high analyst value, no data model dependency.
5. **V8** (Object tree severity heatmap) — small GUI change, no data model dependency.
6. **V9** (Per-chain narrative) — depends on V1/V2 for full content; can land with partial fields.
7. **V6** (Chain completeness bar + reader risk chips in chain panel) — depends on V1.
8. **V4** (Staged DAG layout) — depends on CQ1 `chain.stage` data being emitted by detectors.
9. **V5** (Critical path highlight) — depends on V4 for full value; can land independently.
10. **V10** (MITRE panel) — data already present in EventGraph, no model changes.
11. **V12** (Taint propagation overlay) — depends on V3.
12. **V11** (Revision timeline) — depends on revision finding metadata; read-only mode available immediately.
13. **V13** (Analyst annotation sidecar) — independent of detection work.
14. **V14** (`sis diff` command) — independent, CLI only.

---

## Testing requirements

For each workstream:

- **Data model changes (V1, V2, V3):** Unit tests in `crates/sis-pdf-core/tests/` asserting correct field population from fixture findings. Extend `chain_grouping.rs` for completeness and reader risk. Add `taint_propagation.rs` for V3.
- **GUI changes (V4–V12):** No automated GUI tests (egui rendering is not unit-testable). Instead, document manual verification steps against the CVE fixture: `crates/sis-pdf-core/tests/fixtures/actions/launch_cve_2010_1240.pdf`.
- **CLI (V14):** Integration test in `crates/sis-pdf/tests/` running `sis diff` against two known fixture scan outputs and asserting the diff output.

---

## Risks and mitigations

- **V1/V2 chain_completeness field stability:** If `chain.stage` meta values are absent (pre-CQ1), all stages fall to `inferred` or absent. Acceptable: completeness = 0.0 is a valid output.
- **V4 staged DAG layout quality:** If many nodes share a stage, the column becomes dense. Mitigation: cap column node count at 15; remaining nodes render as a collapsed count node. Apply same collapse strategy as existing `EventNodeKind::Collapse`.
- **V5 critical path BFS performance:** O(V + E) BFS is negligible for 2000-node graphs. Guard: skip if graph has > 5000 edges, emit a notice instead.
- **V2 finding_criticality O(n²) cost:** Guarded at 30 findings per chain. Typical chains have ≤ 5 findings. No performance risk in practice.
- **V13 WASM sidecar:** File write is not available in WASM. Degrade gracefully: in-memory only, show a banner "Annotations cannot be saved in browser mode."
- **V14 diff matching brittleness:** Matching by kind+objects is heuristic. If the same object gets a different ID across scans (xref rebuild), a match may fail. Document this limitation; future improvement can use content-hash matching.

---

## Definition of done

1. `ExploitChain` carries `confirmed_stages`, `inferred_stages`, `chain_completeness`, `reader_risk`, `narrative`, `finding_criticality`, `active_blockers`, `missing_blockers`.
2. `Taint` carries `taint_sources` and `taint_propagation`.
3. Chain panel shows completeness bar, reader risk chips, and narrative for each chain.
4. Graph panel offers: Staged DAG layout mode, critical path highlight toggle, taint propagation overlay toggle, MITRE technique panel.
5. Clicking an evidence span offset in finding detail navigates the hex viewer to that offset.
6. Object inspector shows severity heatmap dots.
7. Revision timeline panel renders (read-only at minimum).
8. Analyst annotation sidecar loads and saves correctly for native builds.
9. `sis diff` command produces correct text and JSON output and exits with code 1 when new critical findings are present.
10. All data model changes have unit tests passing in `cargo test -p sis-pdf-core`.
