# Visualisation and Metadata Uplift Plan: Event Graph, Chains, and Analyst Workflow

Date: 2026-02-20
Status: Proposed
Owner: GUI (`sis-pdf-gui`), core models (`sis-pdf-core`), CLI (`sis-pdf`)

## Goals

1. Make exploit chains immediately readable by analysts without mental reconstruction from flat findings.
2. Expose the data richness that already exists in the event graph model in visual form.
3. Add metadata fields to `ExploitChain` and `Finding` that improve triage, severity composition, and downstream tooling.
4. Provide workflow ergonomics that reduce analyst time on corpus-scale investigations.

## Current state summary

- `ExploitChain` (`chain.rs`): id, group, trigger/action/payload (Option<String>), findings, score, reasons, path, nodes, edges, notes (HashMap<String,String>). No stage vocabulary, no reader risk, no completeness, no narrative.
- Chain panel (`panels/chains.rs`): flat list with score, text path, trigger/action/payload labels, horizontal flow diagram (Trigger → Action → Payload), finding links. No completeness indicator, no reader divergence, no stage alignment.
- Graph panel (`panels/graph.rs`): Fruchterman-Reingold force-directed layout only. `GraphViewMode` has two variants: `Structure` and `Event`. Chain overlay exists (`chain_overlay`, `build_chain_overlay`) but is binary (on/off, equal visual weight). No staged layout, no critical path highlight, no MITRE panel.
- `GraphViewerState`: pan, zoom, hovered/selected node, type/trigger/reader/depth filters, chain filter/overlay. No DAG layout mode, no critical-path state.
- `GraphData` (`graph_data.rs`): `GraphNode` carries object_ref, obj_type, label, roles, confidence, position. `GraphEdge` carries from/to index, suspicious flag, edge_kind, provenance, metadata.
- `EventGraph` (`event_graph.rs`): `EventNode` carries MITRE techniques and kind (Object/Event/Outcome/Collapse). MITRE data is present but never surfaced in any panel.
- `Taint` (`taint.rs`): `flagged: bool`, `reasons: Vec<String>`. No source object refs, no propagation edges.
- `Finding` model: `evidence: Vec<EvidenceSpan>` carries `offset: u64` and `length: u32`. EvidenceSpan byte offsets exist but there is no cross-panel jump from a finding to the hex viewer at that offset.
- `ReaderImpact` on Finding: `profile: ReaderProfile` (Acrobat/Pdfium/Preview), `severity`, `impact`. Present per finding, not aggregated per chain.

## Scope

In scope:
- `ExploitChain` data model enrichment: completeness, reader risk, narrative, per-finding criticality, blocker fields.
- `Taint` model extension: source object refs and propagation edges.
- GUI: staged DAG layout mode, critical path highlight, chain completeness bar, reader risk chips, scatter fan-in rendering, MITRE technique panel, revision timeline panel, taint propagation overlay.
- GUI workflow: evidence-span-to-hex-offset jump navigation, object tree severity heatmap, analyst annotation sidecar.
- CLI: `sis diff` command for finding-level diffing across two scan outputs.

Out of scope (this plan):
- New detector logic (covered in `plans/20260219-detection-uplift.md`).
- Changes to `EventGraph` node/edge model beyond adding taint propagation edges.
- WASM worker protocol changes.

---

## Schema and versioning compatibility

To avoid silent breakage for JSON consumers and query tooling, all chain/report schema changes in this plan must include explicit version signalling and compatibility guards.

Compatibility rules:
- Add `chain_schema_version: u32` to `Report` in `crates/sis-pdf-core/src/report.rs` (initial value: `2`). The version field belongs at the report envelope level, not per-chain, to avoid redundancy and to give consumers a single version check:

  ```rust
  pub struct Report {
      // ... existing fields ...
      /// Schema version for chain-related fields in this report.
      /// Consumers should check this before reading chain metadata fields
      /// added in v2 (confirmed_stages, reader_risk, narrative, etc.).
      #[serde(default)]
      pub chain_schema_version: u32,
  }
  ```

  Set `chain_schema_version = 2` during `Report` construction in `runner.rs`.

- Keep existing fields backwards compatible where practical (`#[serde(default)]` for new optional/additive fields).
- For renamed semantic fields, emit a compatibility alias for one release cycle in JSON output and document deprecation.
- Update query documentation and examples whenever schema version increments.

Validation and gating:
- Add schema compatibility tests in `crates/sis-pdf-core/tests/`:
  - serialise a report with chains and assert `report.chain_schema_version == 2`,
  - deserialise a v1-schema fixture (without chain_schema_version) and assert `chain_schema_version` defaults to `0`, then assert that new additive chain fields default correctly.
- Add CLI/query regression checks ensuring `--format json` and `--jsonl` outputs remain machine-parseable with stable top-level keys.

---

## Phase 1: Data model enrichment

These changes are prerequisites for all visualisation work. They add no GUI code and can land independently.

### V1: ExploitChain completeness and stage fields

**Files:** `crates/sis-pdf-core/src/chain.rs`, `crates/sis-pdf-core/src/chain_synth.rs`

**Changes to `ExploitChain` in `chain.rs`:**

Add fields after `edges`:

```rust
/// Stages confirmed by findings with Probable or higher confidence.
/// Values from the CQ1 vocabulary: "input", "decode", "render", "execute", "egress".
#[serde(default)]
pub confirmed_stages: Vec<String>,

/// Stages inferred by chain synthesis with Tentative or lower confidence.
#[serde(default)]
pub inferred_stages: Vec<String>,

/// Ratio of confirmed stages to total expected stages (0.0–1.0).
#[serde(default)]
pub chain_completeness: f64,

/// Aggregated per-reader risk derived from constituent finding reader_impacts.
/// Key is ReaderProfile::as_str() ("acrobat", "pdfium", "preview").
/// Value is the serialised Severity string ("Critical", "High", etc.).
#[serde(default)]
pub reader_risk: std::collections::HashMap<String, String>,

/// Template-composed natural language summary of the chain.
#[serde(default)]
pub narrative: String,
```

**Changes to `chain_synth.rs`:**

In `finalize_chain`, after `render_path` and before `score_chain`:

1. Collect `chain.stage` values from constituent finding `meta` maps.
   - Finding with `chain.stage` in meta and `confidence >= Probable` → add to `confirmed_stages`.
   - Finding with `chain.stage` in meta and `confidence < Probable` → add to `inferred_stages`.
   - Use canonical stage vocabulary constant (CQ1): `["input", "decode", "render", "execute", "egress"]`.
   - `chain_completeness = confirmed_stage_count / expected_stage_count`.
   - Unknown stage labels do not affect completeness; preserve them in `notes["chain.unknown_stages"]` for triage.

2. Aggregate `reader_risk` from `findings_by_id` → `finding.reader_impacts`:
   - For each `ReaderImpact` in each constituent finding, take the max severity per `profile.as_str()`.
   - Serialise as `severity.to_string()`.

3. Initialise `narrative` to an empty string in V1. Narrative composition is introduced in V9.

**Narrative dependency note:** V1 introduces the `narrative` field only; V9 provides deterministic composition logic and population.

Acceptance criteria:
- A chain with three findings carrying `chain.stage=input`, `chain.stage=execute`, `chain.stage=egress` (all Probable+) has `confirmed_stages = ["input", "execute", "egress"]`, `chain_completeness = 0.6`.
- A chain with all five stages confirmed has `chain_completeness = 1.0`.
- `reader_risk["acrobat"] = "Critical"` when any constituent finding has a Critical Acrobat reader impact.
- Existing `chain_grouping` tests still pass.

### V2: ExploitChain per-finding criticality and blocker fields

**Files:** `crates/sis-pdf-core/src/chain.rs`, `crates/sis-pdf-core/src/chain_synth.rs`

**Changes to `ExploitChain`:**

```rust
/// Per finding-id: how much the chain score drops if that finding is removed (0.0–1.0).
/// Higher = more critical to this chain's exploitability.
#[serde(default)]
pub finding_criticality: std::collections::HashMap<String, f64>,

/// Mitigations confirmed present in the document (from exploit.blockers meta on findings).
#[serde(default)]
pub active_mitigations: Vec<String>,

/// Exploitation requirements gathered from exploit.preconditions metadata.
#[serde(default)]
pub required_conditions: Vec<String>,

/// Required conditions that are not confirmed satisfied in-chain.
#[serde(default)]
pub unmet_conditions: Vec<String>,
```

**Population in `finalize_chain`:**

- `active_mitigations`: collect unique values of `exploit.blockers` and `exploit.mitigations` meta across constituent findings, split by `,`.
- `required_conditions`: collect unique values of `exploit.preconditions` meta across constituent findings.
- `unmet_conditions`: required conditions lacking positive evidence in chain notes/meta; do not treat preconditions as mitigations.
- `finding_criticality`: for each finding id in `chain.findings`, compute `baseline_score - score_without(finding)`:
  - `score_without(fid)` = `score_chain` run on the notes rebuilt from all findings except `fid`.
  - Store delta (clamped 0.0–1.0).
  - This is O(n²) in findings per chain. Given chain size ≤ 20 findings in practice, this is acceptable. Add a guard: skip if `chain.findings.len() > 30`.

Acceptance criteria:
- Removing the sole trigger finding from a chain produces a criticality close to the score delta between a chain with and without an auto-trigger.
- `active_mitigations`, `required_conditions`, and `unmet_conditions` are populated with correct semantics when findings carry `exploit.blockers`, `exploit.mitigations`, and `exploit.preconditions` meta.

### V3: Taint source and propagation extension

**File:** `crates/sis-pdf-core/src/taint.rs`

**Changes to `Taint`:**

```rust
pub struct Taint {
    pub flagged: bool,
    pub reasons: Vec<String>,
    /// PDF object refs that are sources of taint (JS payload, embedded file, etc.).
    pub taint_sources: Vec<(u32, u16)>,
    /// Directed propagation edges: (source_obj, influenced_obj).
    /// Derived from action chain and reference edges in taint-flagging findings.
    pub taint_propagation: Vec<((u32, u16), (u32, u16))>,
}
```

**Population in `taint_from_findings`:**

- For each taint-flagging finding, extract `finding.objects` (parsed as `(u32, u16)` from "obj N M" strings) and add to `taint_sources`.
- Derive `taint_propagation` from explicit provenance edges, not positional spans:
  - prefer correlation metadata edges (`edge.from`, `edge.to`, `edge.shared_objects`) when present,
  - otherwise map object-reference transitions from event-graph/object-graph relationships tied to taint findings.
- Do not infer propagation from `finding.positions`.
- Dedup both lists.

Acceptance criteria:
- A scan with a `js_present` finding on obj 6 0 produces `taint_sources = [(6, 0)]`.
- Propagation edges are non-empty when action chain findings are present.

---

## Phase 2: Core visualisation improvements

These are GUI changes in `sis-pdf-gui`. They depend on Phase 1 data being present.

### V4: Staged DAG layout mode

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/graph_layout.rs` (new `graph_layout_dag.rs`)

**Changes to `GraphViewMode` in `panels/graph.rs`:**

```rust
pub enum GraphViewMode {
    Structure,
    Event,
    StagedDag, // new
}
```

**New `graph_layout_dag.rs`:**

```rust
/// Column assignment for staged DAG layout.
/// Maps chain.stage values and node roles to column index 0–4.
pub fn stage_column(node: &GraphNode) -> usize {
    // Check roles vec for stage markers set during from_event_graph conversion.
    // "input" -> 0, "decode" -> 1, "render" -> 2, "execute" -> 3, "egress" -> 4
    // Outcome nodes with OutcomeType::NetworkEgress/FormSubmission -> 4
    // Outcome nodes with OutcomeType::CodeExecution -> 3
    // Event nodes with TriggerClass::Automatic/Hidden -> 0
    // Default: 2 (render/middle)
}

/// Assign positions for a staged DAG layout.
/// Column width = area_w / 5.0. Nodes within a column are distributed vertically.
pub fn apply_dag_layout(graph: &mut GraphData) {
    let area_w = 800.0f64;
    let area_h = 600.0f64;
    let col_w = area_w / 5.0;
    // Group nodes by column, assign y positions evenly within column.
    // Back-edges (egress → input) rendered as curved arcs; handled at draw time by
    // checking that edge from_col > to_col.
}
```

**Changes to `GraphViewerState`:**

Add `dag_layout_dirty: bool` — set when switching to StagedDag mode to trigger re-layout.

**Changes to `show_toolbar` in `panels/graph.rs`:**

Add a third layout mode button: `[Force-directed] [Event] [Staged DAG]`.

**Rendering changes for StagedDag mode:**

In the draw loop, when `mode == StagedDag`:
- Draw 5 vertical lane separators (light grey, 1px) at column boundaries.
- Draw column header labels (INPUT / DECODE / RENDER / EXECUTE / EGRESS) at top.
- Render back-edges (from_col > to_col) as curved Bézier arcs drawn above the lane headers.
- All other rendering (node colours, labels, tooltips) unchanged.

**Column overflow handling:**

When a column contains more than 15 visible nodes, render it as a fixed-height scrollable sub-area rather than collapsing nodes to a count badge. Each column is an independent scrollable region; nodes are never removed or aggregated. This preserves full node visibility and interaction while preventing layout overflow.

Implementation: track a per-column `scroll_offset: f64` in `GraphViewerState` (e.g. `dag_column_scroll: [f64; 5]`). Mouse-wheel events within a column's screen rect adjust that column's scroll offset. Node screen positions are computed after applying the column scroll.

Acceptance criteria:
- Switching to Staged DAG mode places event nodes in the leftmost columns and outcome nodes in the rightmost.
- Back-edges are visually distinct from forward edges.
- All existing node colours and tooltips are preserved.
- A column with more than 15 nodes is scrollable; all nodes remain accessible without any being hidden or collapsed.

**Deliverables:**
- `graph_layout_dag.rs` with `stage_column` and `apply_dag_layout`.
- `GraphViewMode::StagedDag` variant and toolbar button.
- Per-column scroll state in `GraphViewerState`.
- Benchmark test `graph_layout_staged_dag_budget` in `crates/sis-pdf-gui/` asserting layout time ≤ 25 ms for 2,000 nodes / 5,000 edges.

### V5: Critical path highlight

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/graph_data.rs`

**Changes to `GraphViewerState`:**

```rust
/// Set of (from_idx, to_idx) edge pairs on the highest-scoring path.
pub critical_path_edges: std::collections::HashSet<(usize, usize)>,
/// Node indices on the critical path.
pub critical_path_nodes: std::collections::HashSet<usize>,
/// Whether to show only the critical path (dims non-path nodes).
pub show_critical_path: bool,
```

**New function `compute_critical_path(graph: &GraphData, event_graph: &EventGraph) -> (HashSet<(usize, usize)>, HashSet<usize>)`:**

- Forward BFS from all `TriggerClass::Automatic` event nodes.
- Edge weight = confidence of the `to` node (use `GraphNode::confidence.unwrap_or(0.5)`).
- Path score = product of edge weights.
- Return the (from_idx, to_idx) pairs on the maximum-weight path from any trigger to any Outcome node.
- Call after graph is built in `build_graph`.

**Rendering changes:**

When `show_critical_path`:
- Critical path edges: stroke width 3.0 px (vs default 1.0), colour `Color32::from_rgb(255, 140, 0)`.
- Critical path nodes: full opacity, stroke width 2.0.
- All other nodes and edges: `Color32` alpha reduced to 50 (≈20% opacity). Achieved by blending with background colour.
- Toolbar toggle: `[Critical path]` button beside existing controls.

Acceptance criteria:
- A document with a single OpenAction → JavaScript → NetworkEgress chain shows the three nodes and two edges highlighted.
- Non-path nodes are visibly dimmed.
- Toggle restores full rendering.

**Deliverables:**
- `compute_critical_path` function in `panels/graph.rs` or `graph_data.rs`.
- `critical_path_edges`, `critical_path_nodes`, `show_critical_path` fields on `GraphViewerState`.
- Toolbar toggle button.
- Benchmark test `critical_path_budget` asserting path computation ≤ 15 ms for 2,000 nodes / 5,000 edges.

### V6: Chain completeness bar in chain panel

**File:** `crates/sis-pdf-gui/src/panels/chains.rs`

**Changes to `ChainDisplay`:**

```rust
struct ChainDisplay {
    // ... existing fields ...
    confirmed_stages: Vec<String>,
    inferred_stages: Vec<String>,
    chain_completeness: f64,
    reader_risk: std::collections::HashMap<String, String>,
    narrative: String,
}
```

Populate from `chain.confirmed_stages`, `chain.inferred_stages`, `chain.chain_completeness`, `chain.reader_risk`, `chain.narrative`.

**New function `show_completeness_bar(ui, confirmed, inferred)`:**

```
ui.horizontal(|ui| {
    for stage in &["INPUT", "DECODE", "RENDER", "EXECUTE", "EGRESS"] {
        let lower = stage.to_lowercase();
        let colour = if confirmed.contains(&lower) { Color32::GREEN }
                     else if inferred.contains(&lower) { Color32::YELLOW }
                     else { Color32::DARK_GRAY };
        ui.colored_label(colour, *stage);
        ui.label(" ");
    }
    ui.label(format!("{:.0}% complete", chain_completeness * 100.0));
});
```

**New function `show_reader_risk_chips(ui, reader_risk)`:**

```
ui.horizontal(|ui| {
    for profile in &["acrobat", "pdfium", "preview"] {
        if let Some(sev) = reader_risk.get(*profile) {
            let colour = severity_colour(sev);  // reuse existing severity_colour logic
            ui.colored_label(colour, format!("{}: {}", profile, sev));
            ui.add_space(4.0);
        }
    }
});
```

Place completeness bar and reader risk chips below the existing flow diagram in each chain group.

**Add narrative display:**

Below reader risk chips, render `chain.narrative` as a wrapped label when non-empty.

Acceptance criteria:
- A chain with three confirmed stages shows three green labels and two grey labels.
- Inferred stages render in yellow.
- Reader risk chips show correct colours per severity.

### V7: Evidence span to hex viewer jump navigation

**Files:** `crates/sis-pdf-gui/src/panels/detail.rs`, `crates/sis-pdf-gui/src/app.rs`

**Current state:** `EvidenceSpan` has `offset: u64` and `length: u32`. The finding detail panel renders evidence spans as plain text. The hex viewer exists (`panels/hex_viewer.rs`) with `HexViewState` in `SisApp`.

**Changes to `panels/detail.rs`:**

In the evidence span rendering section, replace plain text with a clickable link:

```rust
for span in &finding.evidence {
    let label = format!("offset 0x{:x} ({} bytes)", span.offset, span.length);
    if ui.link(&label).clicked() {
        app.hex_view.jump_to = Some(HexJumpTarget {
            offset: span.offset,
            length: span.length,
            source: span.source.clone(),
        });
        app.show_hex = true;
    }
}
```

**Changes to `HexViewState` in `app.rs`:**

Add structured jump state:

```rust
pub struct HexJumpTarget {
    pub offset: u64,
    pub length: u32,
    pub source: EvidenceSource,
}
pub jump_to: Option<HexJumpTarget>;
```

In `panels/hex_viewer.rs`, when `jump_to` is set: scroll to `offset`, highlight `length` bytes, display source context (`File` vs `Decoded`), then clear `jump_to`.

Acceptance criteria:
- Clicking an evidence span offset in the finding detail panel opens the hex viewer at that byte offset.
- The relevant bytes are visually highlighted.
- The jump works for both `EvidenceSource::File` and `EvidenceSource::Decoded` spans (with a label distinguishing them).

### V8: Object tree severity heatmap

**Files:** `crates/sis-pdf-gui/src/panels/objects.rs`, `crates/sis-pdf-gui/src/analysis.rs`

**Changes to `AnalysisResult` in `analysis.rs`:**

Add pre-computed index after scan:

```rust
/// Map from (obj, gen) to (max_severity, finding_count) for the object heatmap.
pub object_severity_index: std::collections::HashMap<(u32, u16), (Severity, usize)>,
```

Populate during result construction by iterating `report.findings` and extracting `finding.objects` → parse as `(u32, u16)` → accumulate max severity and count.

**Changes to `panels/objects.rs`:**

In the object list row rendering, add a coloured severity dot and count badge before the object label:

```rust
if let Some((max_sev, count)) = result.object_severity_index.get(&(obj, gen)) {
    let colour = severity_colour_for(max_sev);
    // Draw filled circle (radius 5.0) in severity colour
    // Draw count badge: small grey label "(N)"
}
```

Acceptance criteria:
- Objects with findings show a coloured dot (red for Critical/High, orange for Medium, grey for Low/Info).
- Objects with no findings show no dot.
- Finding count badge is accurate.

---

## Phase 3: New panels

### V9: Per-chain narrative composition

**File:** `crates/sis-pdf-core/src/chain_render.rs`

**New function:**

```rust
pub fn compose_chain_narrative(chain: &ExploitChain) -> String
```

Template-driven composition from structured chain fields. No external dependencies.

Template skeleton:

```
"{trigger_desc} {action_desc}{scatter_clause}{payload_clause}.{precondition_clause}{blocker_clause}"
```

Field mapping:
- `trigger_desc`: derived from `notes["trigger.label"]` or `chain.trigger` →
  - `open_action_present` → "An automatic document-open action"
  - `aa_event_present` → "A field event action"
  - default → "An action"
- `action_desc`: `notes["action.type"]` →
  - `JavaScript` → "executes JavaScript"
  - `Launch` → "launches an external process"
  - `SubmitForm` → "submits form data"
  - `URI` → "opens a URI"
  - default → "triggers an action"
- `scatter_clause`: if `notes["scatter.fragment_count"]` present → ` assembling a payload from {n} document fragments`
- `payload_clause`: from `notes["payload.type"]` and `notes["payload.summary"]`
- `precondition_clause`: if `chain.unmet_conditions` non-empty → ` Exploitation requires: {list}.`
- `blocker_clause`: if `chain.active_mitigations` non-empty → ` Mitigated by: {list}.`

Call `compose_chain_narrative` in `finalize_chain` (after score) and assign to `chain.narrative`.

Acceptance criteria:
- A chain with trigger=open_action_present, action=js_present, payload=javascript produces a non-empty narrative sentence.
- A chain with `scatter.fragment_count=3` includes the fragment count in the narrative.
- Narrative is stable across identical inputs (deterministic).

### V10: MITRE ATT&CK technique panel

**Files:** new `crates/sis-pdf-gui/src/panels/mitre.rs`, `crates/sis-pdf-gui/src/panels/mod.rs`, `crates/sis-pdf-gui/src/app.rs`

**Data source:** `EventGraph::nodes` where `node.mitre_techniques` is non-empty.

**`SisApp` additions:**

```rust
pub show_mitre: bool,
/// Set of EventNodeId values to highlight in the graph.
pub mitre_highlight: Option<std::collections::HashSet<EventNodeId>>,
/// Currently selected MITRE technique id (for panel state and clear/reset logic).
pub mitre_selected_technique: Option<String>,
```

**`panels/mitre.rs` implementation:**

1. Collect all (technique_id, Vec<EventNodeId>) pairs from the event graph, sorted by technique ID.
2. Render as a scrollable list:
   ```
   [T1204.002] User Execution: Malicious File  (3 nodes)
   [T1059.007] JavaScript                       (1 node)
   ```
3. Clicking a technique:
   - Sets `app.mitre_highlight = Some(set_of_node_ids_for_technique)`.
   - Sets `app.mitre_selected_technique = Some(technique_id.to_string())`.
   - Highlights those nodes in the graph panel (uses same dimming mechanism as critical path).

**Graph panel rendering change:**

When `app.mitre_highlight` is set, nodes whose `EventNodeId` is in the set render with a purple border ring (2px, `Color32::from_rgb(180, 80, 220)`). All others dimmed to 50% opacity.

Acceptance criteria:
- Panel lists all MITRE techniques present in the event graph with accurate node counts.
- Clicking a technique highlights the correct nodes in the graph.
- Closing the panel clears `mitre_highlight`.

### V11: Revision timeline panel

**Files:** new `crates/sis-pdf-gui/src/panels/revision.rs`, `crates/sis-pdf-gui/src/panels/mod.rs`

**Data source:** Findings with kinds `incremental_update_chain`, `revision_forensics_present`, `shadow_hide_attack`, `shadow_replace_attack`, `object_id_shadowing`. These findings carry object refs and `meta` fields recording revision numbers.

**Panel layout:**

Horizontal scrollable timeline. Each revision is a vertical column:

```
Rev 1 (baseline)     Rev 2 (+42 objs)     Rev 3 (+7 objs, post-cert)
[baseline]           [obj 6 0 added]      [obj 41-47 added]
                     [obj 9 0 added]      [obj 9 0 shadowed by obj 47 0]
```

- Revisions extracted from `meta["revision.index"]` on findings, deduplicated and sorted.
- Shadow attack objects highlighted with a `Color32::RED` border and a "post-cert" label when `meta["revision.post_cert"] == "true"`.
- Clicking a revision column filters the event graph: `app.graph_state.event_trigger_filter` set to show only objects introduced in that revision (requires the event graph to carry revision provenance on nodes via `EdgeMetadata`).

**Note on filtering:** Full revision-based graph filtering requires revision metadata on `EventNode` objects. If that metadata is absent, the panel is rendered read-only (click shows a tooltip listing affected objects but does not filter the graph). This is a graceful degradation.

Acceptance criteria:
- Panel renders without error when no revision findings are present (shows "No incremental revisions detected").
- Panel shows correct revision counts when revision findings are present.
- Shadow attack objects are visually distinct.

### V12: Taint propagation overlay

**Files:** `crates/sis-pdf-gui/src/panels/graph.rs`, `crates/sis-pdf-gui/src/app.rs`

**Prerequisite:** V3 (Taint source and propagation extension).

**`GraphViewerState` addition:**

```rust
/// Whether to show taint propagation as an overlay.
pub show_taint_overlay: bool,
/// Pre-computed taint edge set: (from_idx, to_idx) derived from Taint::taint_propagation.
pub taint_edges: Vec<(usize, usize)>,
/// Node indices that are taint sources.
pub taint_source_nodes: std::collections::HashSet<usize>,
```

**Population:**

After graph is built, resolve `Taint::taint_sources` and `Taint::taint_propagation` through `GraphData::node_index` to produce `taint_source_nodes` and `taint_edges`.

**Rendering:**

When `show_taint_overlay`:
- Taint source nodes: red border ring (3px, `Color32::RED`).
- Taint propagation edges: rendered as dashed strokes (approximate with short line segments at 6px intervals) in `Color32::from_rgb(200, 60, 60)`.
- Non-taint nodes and edges: rendered at 40% opacity.
- Toolbar toggle: `[Taint]` button.

Acceptance criteria:
- Taint overlay shows source nodes and propagation edges when taint is present.
- Overlay is independent of the critical path and chain overlays (each can be toggled independently).
- When `Taint::flagged == false`, toggle button is disabled (greyed out).

**Deliverables:**
- `show_taint_overlay`, `taint_edges`, `taint_source_nodes` fields on `GraphViewerState`.
- Resolution pass mapping `Taint::taint_sources`/`taint_propagation` through `GraphData::node_index`.
- Toolbar toggle button.
- Benchmark test `taint_overlay_mapping_budget` asserting source/edge index resolution ≤ 10 ms for 2,000 nodes.

---

## Phase 4: Workflow ergonomics

### V13: Analyst annotation sidecar

**Files:** new `crates/sis-pdf-gui/src/annotations.rs`, changes to `app.rs`, `panels/findings.rs`, `panels/chains.rs`

**Data model (`annotations.rs`):**

```rust
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq)]
pub enum TriageState {
    Pending,
    Confirmed,
    FalsePositive,
    Mitigated,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Annotation {
    pub finding_id: String,
    pub note: String,
    pub triage_state: TriageState,
    pub timestamp_unix: u64,
}

#[derive(Debug, Default, serde::Serialize, serde::Deserialize)]
pub struct AnnotationStore {
    /// SHA-256 of the analysed PDF (hex string). Guards against applying annotations
    /// from a different document.
    pub document_sha256: String,
    pub annotations: std::collections::HashMap<String, Annotation>,
}

impl AnnotationStore {
    /// Load from a `.sis-notes.json` sidecar file beside the PDF path.
    pub fn load(pdf_path: &std::path::Path) -> Self { ... }
    /// Save to the sidecar file.
    pub fn save(&self, pdf_path: &std::path::Path) -> std::io::Result<()> { ... }
    /// Path convention: `{pdf_path}.sis-notes.json`
    pub fn sidecar_path(pdf_path: &std::path::Path) -> std::path::PathBuf { ... }
}
```

**SHA-256 sourcing:**

`document_sha256` must come from `AnalysisResult`, which computes and stores the hash at parse time. It must never be recomputed at annotation save time to avoid a race condition where the PDF bytes change between analysis and save.

Add `document_sha256: String` to `AnalysisResult` in `crates/sis-pdf-gui/src/analysis.rs`, populated from the scan result during result construction. `AnnotationStore::save` and `AnnotationStore::load` both receive the hash from `&app.result` rather than accepting a file path for hashing. The sidecar path is still derived from the PDF file path; only the integrity hash comes from `AnalysisResult`.

```rust
// In AnnotationStore:
pub fn load(sidecar_path: &std::path::Path, document_sha256: &str) -> Self { ... }
pub fn save(&self, sidecar_path: &std::path::Path) -> std::io::Result<()> { ... }
pub fn sidecar_path(pdf_path: &std::path::Path) -> std::path::PathBuf { ... }

// In SisApp save call:
let path = AnnotationStore::sidecar_path(&app.pdf_path);
app.annotations.save(&path)?;

// In SisApp load call:
let path = AnnotationStore::sidecar_path(&pdf_path);
app.annotations = AnnotationStore::load(&path, &result.document_sha256);
```

**`SisApp` additions:**

```rust
pub annotations: crate::annotations::AnnotationStore,
pub annotation_edit_finding: Option<String>, // finding_id being annotated
```

**`panels/findings.rs` changes:**

In each finding row, add an annotation icon column (a coloured circle):
- No annotation: empty circle, grey.
- `Confirmed`: filled green circle.
- `FalsePositive`: filled red circle.
- `Mitigated`: filled blue circle.
- `Pending`: filled yellow circle.
- Clicking the icon opens an inline annotation editor (egui popup with: note text area, triage state selector, save/clear buttons).

**`panels/chains.rs` changes:**

Show triage state aggregate for a chain: if all constituent findings are `FalsePositive` → mark chain as `[FP]`. If all are `Mitigated` → mark chain as `[OK]`.

**Persistence:** Annotations are saved to the sidecar on every change (call `store.save(pdf_path)`). If `pdf_path` is not available (WASM drag-drop), annotations are kept in memory only and a notice is shown.

Acceptance criteria:
- An annotation added to a finding persists across app restarts when a file path is available.
- The sidecar is rejected (and a warning shown) if `document_sha256` does not match the loaded document.
- Findings with annotations show the correct triage colour.

### V14: `sis diff` command

**Files:** new `crates/sis-pdf/src/commands/diff.rs`, `crates/sis-pdf/src/commands/mod.rs`

**Command interface:**

```
sis diff <baseline.jsonl> <comparison.jsonl> [--format text|json]
```

Accepts two scan output files (JSONL, one finding per line or one report per line).

**Output (text):**

```
+ NEW   [High/Strong]   js_present             (obj 6 0)
+ NEW   [Critical/Certain] launch_action_present (obj 9 0)
- GONE  [Medium/Probable] uri_content_analysis   (obj 3 0)
~ CHANGED js_sandbox_exec  Medium/Strong -> High/Strong
```

**Output (JSON):**

```json
{
  "new_findings": [...],
  "removed_findings": [...],
  "changed_findings": [
    { "id": "...", "kind": "...", "baseline": { "severity": "...", "confidence": "..." },
      "comparison": { "severity": "...", "confidence": "..." } }
  ]
}
```

**Matching logic:** Findings are matched by a stable fingerprint, not `id`:
- `kind`
- canonical sorted object refs
- stable context keys when present: `chain.stage`, `action_type`, `edge.reason`
- `action_target` when present, normalised before fingerprinting: strip query parameters and URI fragments to avoid session tokens and timestamps defeating cross-scan matching (e.g. `https://example.com/collect?sid=abc123` → `https://example.com/collect`)
- optional evidence anchor (`evidence[0].offset`) when available

A finding is "changed" if fingerprints match but severity/confidence or selected context fields differ. If multiple candidates share a fingerprint, perform deterministic tie-break by highest confidence then lexicographic `kind`.

**Exit codes:** 0 = no new high/critical findings; 1 = new high/critical findings present. Useful for CI integration.

Acceptance criteria:
- `sis diff a.jsonl b.jsonl` correctly identifies new, removed, and changed findings.
- `--format json` produces machine-parseable output.
- Exit code 1 when new Critical findings are present.

**Deliverables:**
- `crates/sis-pdf/src/commands/diff.rs` implementing the command.
- Registration in `crates/sis-pdf/src/commands/mod.rs`.
- Integration tests in `crates/sis-pdf/tests/` asserting correct new/removed/changed output against two known fixture scan outputs.
- Benchmark test `diff_large_input_budget` asserting diff completes ≤ 2.0 s and ≤ 300 MB RSS for 100k findings per input file.

---

## Delivery sequence

1. **V3** (Taint model extension) — no GUI impact, low risk. Run `cargo test -p sis-pdf-core`.
2. **V1** (ExploitChain completeness + reader risk) — data model only. Run `cargo test -p sis-pdf-core --test chain_grouping`.
3. **V2** (ExploitChain criticality + blockers) — data model only, same test suite.
4. **V7** (Evidence span → hex viewer jump) — small GUI change, high analyst value, no data model dependency.
5. **V8** (Object tree severity heatmap) — small GUI change, no data model dependency.
6. **V9** (Per-chain narrative) — depends on V1/V2 for full content; can land with partial fields.
7. **V6** (Chain completeness bar + reader risk chips in chain panel) — depends on V1.
8. **V4** (Staged DAG layout) — depends on CQ1 `chain.stage` data being emitted by detectors.
9. **V5** (Critical path highlight) — depends on V4 for full value; can land independently.
10. **V10** (MITRE panel) — data already present in EventGraph, no model changes.
11. **V12** (Taint propagation overlay) — depends on V3.
12. **V11** (Revision timeline) — depends on revision finding metadata; read-only mode available immediately.
13. **V13** (Analyst annotation sidecar) — independent of detection work.
14. **V14** (`sis diff` command) — independent, CLI only.

---

## Testing requirements

For each workstream:

- **Data model changes (V1, V2, V3):** Unit tests in `crates/sis-pdf-core/tests/` asserting correct field population from fixture findings. Extend `chain_grouping.rs` for completeness and reader risk. Add `taint_propagation.rs` for V3.
- **GUI changes (V4–V12):** Add deterministic non-render tests for layout/state logic plus manual verification:
  - stage-column assignment and DAG lane placement,
  - critical-path scoring/path selection,
  - taint source/edge index mapping,
  - MITRE selection/highlight state transitions.
  Manual verification remains required for visual styling using fixture `crates/sis-pdf-core/tests/fixtures/actions/launch_cve_2010_1240.pdf`.
- **CLI (V14):** Integration test in `crates/sis-pdf/tests/` running `sis diff` against two known fixture scan outputs and asserting the diff output.

## Fixture requirements for uplift validation

Add explicit fixtures aligned with modern distributed and obfuscated exploitation patterns:

1. Complex/distributed/fragmented chain fixtures:
- Multi-object trigger/action/payload chains with fragmented evidence across decode/render/execute stages.
- Include at least one chain requiring correlation edges (`edge.reason`) to connect non-adjacent findings.

2. Revision-shadow fixtures:
- Incremental-update PDFs with object shadowing and post-cert revisions.
- Must exercise `revision.index`, `revision.post_cert`, and timeline panel read-only fallback path.

3. Multi-reader divergence fixtures:
- PDFs where Acrobat/Pdfium/Preview impacts diverge by severity/impact.
- Must validate `reader_risk` aggregation and per-chain reader chip rendering.

Fixture governance:
- Register all new fixtures in corpus manifests where applicable.
- Add fixture provenance notes under `crates/sis-pdf-core/tests/fixtures/README.md`.
- Include at least one drift guard assertion per fixture family (stage ordering, edge connectivity, reader-risk consistency).

## Performance budgets and gates

Each feature lands with measurable budgets and repeatable benchmark commands.

Budgets:
- V4 staged DAG layout: <= 25 ms layout time for 2,000 nodes / 5,000 edges.
- V5 critical path computation: <= 15 ms for 2,000 nodes / 5,000 edges.
- V12 taint overlay mapping: <= 10 ms edge/node mapping for 2,000 nodes.
- V14 `sis diff`: <= 2.0 s and <= 300 MB RSS for 100k findings per input file.

Benchmark commands (to be added as regression/perf tests where missing):
1. `cargo test -p sis-pdf-gui graph_layout_staged_dag_budget -- --nocapture`
2. `cargo test -p sis-pdf-gui critical_path_budget -- --nocapture`
3. `cargo test -p sis-pdf-gui taint_overlay_mapping_budget -- --nocapture`
4. `cargo test -p sis-pdf diff_large_input_budget -- --nocapture`
5. `cargo run -p sis-pdf --bin sis -- scan crates/sis-pdf-core/tests/fixtures/actions/launch_cve_2010_1240.pdf --deep --runtime-profile --runtime-profile-format json`

Gates:
- Any budget regression > 20% blocks merge unless an explicit waiver is documented in the active plan with rationale.
- Runtime-profile deltas affecting parse/detection SLO rows must be recorded in this plan.

---

## Risks and mitigations

- **V1/V2 chain_completeness field stability:** If `chain.stage` meta values are absent (pre-CQ1), all stages fall to `inferred` or absent. Acceptable: completeness = 0.0 is a valid output.
- **V4 staged DAG layout quality:** If many nodes share a stage, the column becomes dense. Mitigation: columns with more than 15 nodes use an independent intra-column scroll region. Nodes are never collapsed or hidden; all remain reachable via scroll. Per-column scroll offsets are tracked in `dag_column_scroll: [f64; 5]` on `GraphViewerState`.
- **V5 critical path BFS performance:** O(V + E) BFS is negligible for 2000-node graphs. Guard: skip if graph has > 5000 edges, emit a notice instead.
- **V2 finding_criticality O(n²) cost:** Guarded at 30 findings per chain. Typical chains have ≤ 5 findings. No performance risk in practice.
- **V13 WASM sidecar:** File write is not available in WASM. Degrade gracefully: in-memory only, show a banner "Annotations cannot be saved in browser mode."
- **V14 diff matching brittleness:** Fingerprint collisions remain possible for structurally similar findings. Mitigation: context-enriched fingerprint plus deterministic tie-break rules and collision counters in test fixtures.

---

## Definition of done

1. `ExploitChain` carries `confirmed_stages`, `inferred_stages`, `chain_completeness`, `reader_risk`, `narrative`, `finding_criticality`, `active_mitigations`, `required_conditions`, `unmet_conditions`.
2. `Taint` carries `taint_sources` and `taint_propagation`.
3. `Report` carries `chain_schema_version: u32` set to `2`; schema compatibility tests assert version value and additive-field defaults against a v1 fixture.
4. Chain panel shows completeness bar, reader risk chips, and narrative for each chain.
5. Graph panel offers: Staged DAG layout mode (with per-column scroll, no collapse), critical path highlight toggle, taint propagation overlay toggle, MITRE technique panel.
6. Clicking an evidence span offset in finding detail navigates the hex viewer to that offset.
7. Object inspector shows severity heatmap dots.
8. Revision timeline panel renders (read-only at minimum).
9. Analyst annotation sidecar loads and saves correctly for native builds; `document_sha256` sourced from `AnalysisResult`, never recomputed at save time.
10. `sis diff` command produces correct text and JSON output, normalises `action_target` before fingerprinting, and exits with code 1 when new critical findings are present.
11. All data model changes have unit tests passing in `cargo test -p sis-pdf-core`.
12. Benchmark tests for V4, V5, V12, V14 exist and pass within defined performance gates.
13. `exploit.mitigations` is the canonical key across both plans; `exploit.blockers` is accepted as a deprecated read alias for one release cycle.
