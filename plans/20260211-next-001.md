# Next Implementation Plan: JS Sandbox High/Medium Feasibility Items

Date: 2026-02-11  
Status: Proposed  
Scope: `crates/js-analysis`, `crates/sis-pdf-detectors`, docs updates

## 1. Objective

Implement the highest-value modernisation work identified in `docs/research/20260211-js-path.md`, focused on:

- improved runtime fidelity for modern web malware behaviours,
- stronger source-to-sink intent attribution,
- deeper WASM and prototype-abuse signal quality,
- optional Node/Bun lifecycle coverage for supply-chain scripts.

Out of scope for this plan:

- global payload limit increase to 50 MiB,
- speculative agentic malware attribution heuristics.

## 2. Guardrails and Constraints

- No `unsafe` and no `unwrap` usage.
- Preserve deterministic output under identical input/options.
- Preserve bounded resource usage (time, loops, recursion, telemetry cardinality).
- No real network/filesystem side-effects from stubs.
- Maintain stable query/output schema; additive metadata keys only.

## 3. Workstream Summary (MECE)

1. **WS-A**: Service Worker lifecycle emulation and persistence telemetry.  
2. **WS-B**: WebSocket/WebRTC deep telemetry and session-level exfil signal extraction.  
3. **WS-C**: Dynamic taint-lite source-to-sink correlation.  
4. **WS-D**: Exfil URL/domain feature expansion and scoring refinement.  
5. **WS-E**: WASM bytecode and runtime combined signal model.  
6. **WS-F**: Prototype pollution gadget correlation model.  
7. **WS-G**: Node/Bun lifecycle script profile support.

---

## 4. Detailed Technical Plan

## WS-A: Service Worker lifecycle emulation and persistence telemetry (High)

### A.1 Runtime surface

Extend browser-like stubs in `crates/js-analysis/src/dynamic.rs`:

- `navigator.serviceWorker.register/getRegistration/getRegistrations/ready/update`
- `ServiceWorkerRegistration.update/unregister/showNotification`
- synthetic worker event handlers:
  - `self.addEventListener('install'|'activate'|'fetch'|'push'|'sync', ...)`
  - `clients.claim`, `skipWaiting`

### A.2 Orchestration changes

Add synthetic lifecycle phases (internal only; keep user-facing phase model stable):

- `sw_install`
- `sw_activate`
- `sw_fetch`
- `sw_push`
- `sw_sync`

Execution order:

1. existing page phases (`open`, `idle`, `click`, `form`)
2. worker lifecycle micro-phases when worker registration is observed.

### A.3 Telemetry additions

Add metadata keys under `js.runtime.service_worker.*`:

- `registration_calls`
- `update_calls`
- `event_handlers_registered`
- `lifecycle_events_executed`
- `cache_calls`
- `indexeddb_calls`

### A.4 Pattern and finding updates

Refine/extend existing `service_worker_persistence_abuse`:

- require lifecycle/event evidence rather than only registration + cache.
- confidence uplift when fetch/push/sync event path executes.

Detector:

- keep kind `js_runtime_service_worker_persistence`.
- add explicit lifecycle evidence fields in finding metadata.

### A.5 Tests

- `dynamic_signals.rs`: positive/negative cases for registration-only vs full lifecycle.
- integration: ensure finding emitted only with lifecycle criteria.
- regression: deterministic phase ordering with and without worker registration.

---

## WS-B: WebSocket/WebRTC deep telemetry and session-level exfil signals (High)

### B.1 Runtime surface

Expand stubs:

- `new WebSocket(url, protocols?)` constructor-level capture.
- `WebSocket.send/close`
- `RTCPeerConnection` session methods:
  - `createOffer/createAnswer/setLocalDescription/setRemoteDescription/addIceCandidate`
- `RTCDataChannel.send/close`

### B.2 Telemetry model

Add session-oriented telemetry:

- `js.runtime.realtime.session_count`
- `js.runtime.realtime.unique_targets`
- `js.runtime.realtime.send_count`
- `js.runtime.realtime.avg_payload_len`
- `js.runtime.realtime.channel_types` (`websocket`, `rtc_datachannel`)

### B.3 Behaviour refinements

Refine `covert_realtime_channel_abuse`:

- differentiate setup-only vs active transfer.
- confidence calibration by chain completeness:
  - setup + send + encoding + repeated send => high.

### B.4 Tests

- unit: setup-only should not trigger high-confidence chain.
- unit: repeated encoded sends triggers pattern.
- integration: finding metadata includes realtime session keys.

---

## WS-C: Dynamic taint-lite source-to-sink correlation (High)

### C.1 Design

Implement lightweight provenance tagging (no full VM taint):

- record source events when APIs accessed:
  - `document.cookie`
  - `localStorage.getItem/sessionStorage.getItem`
  - form field reads (`getField`, DOM value reads)
  - clipboard reads
- record sink events:
  - execution sinks: `eval`, `Function`
  - network sinks: `fetch`, `sendBeacon`, `WebSocket.send`, `RTCDataChannel.send`, `XMLHTTP.send`

Correlation rule:

- if source event precedes sink within N calls/phases, emit a correlation edge.

### C.2 Data model

Add internal edge records:

- `source`
- `sink`
- `call_distance`
- `phase_source`
- `phase_sink`

Expose aggregated metadata:

- `js.runtime.taint.edges`
- `js.runtime.taint.source_types`
- `js.runtime.taint.sink_types`
- `js.runtime.taint.max_call_distance`

### C.3 Pattern integration

Use edges to strengthen confidence for:

- `clipboard_session_hijack_behaviour`
- `chunked_data_exfil_pipeline`
- `credential_harvest_form_emulation`

### C.4 Tests

- positive: cookie/storage/form/clipboard to send/eval.
- negative: source without sink and sink without source.
- determinism: stable edge ordering and serialisation.

---

## WS-D: Exfil URL/domain feature expansion and scoring refinement (High)

### D.1 Feature extractor

Centralise URL/domain feature extraction utility:

- query length, key-value density, label depth
- entropy measures for subdomain and query
- encoded token presence (`%2f`, `%3d`, `%2b`, base64-like chunks)
- target repetition across calls/phases

### D.2 Scoring model

Replace ad hoc thresholds with weighted score table:

- network sink presence (base)
- encoded payload indicators
- repeated target cadence
- high-entropy/high-density query traits

Use calibrated score bands:

- Low confidence: weak single-signal
- Probable/Strong: multi-signal with repeated send behaviour.

### D.3 Pattern integration

Apply to:

- `covert_beacon_exfil`
- `chunked_data_exfil_pipeline`

### D.4 Tests

- table-driven test vectors for score bands.
- malicious fixture replays where previous false negatives existed.

---

## WS-E: WASM bytecode + runtime combined model (Medium)

### E.1 Static byte feature pre-pass

For likely WASM binaries or embedded buffers:

- preamble detection (`\0asm`)
- section map extraction (type/import/function/table/memory/export)
- suspicious import names (`env.eval`, `env.fetch`, dynamic dispatch shims)
- memory/table density and anomalous section sizes

Bounded parsing:

- strict length checks,
- maximum sections,
- early exit on malformed data.

### E.2 Runtime correlation

Correlate static features with runtime calls:

- `WebAssembly.instantiate/compile/Module/Memory/Table`
- decode/unpack primitives
- dynamic execution sinks

### E.3 Pattern updates

Refine:

- `wasm_loader_staging`
- `wasm_memory_unpacker_pipeline`

Add metadata:

- `js.runtime.wasm.static.suspicious_imports`
- `js.runtime.wasm.static.section_count`
- `js.runtime.wasm.static.memory_sections`
- `js.runtime.wasm.correlation_score`

### E.4 Tests

- fixture-like byte arrays for benign vs suspicious imports.
- regression for malformed modules (must fail safely).
- pattern confidence uplift only when static+runtime correlate.

---

## WS-F: Prototype pollution gadget correlation (Medium)

### F.1 Mutation capture

Extend mutation capture with:

- `__proto__`, `prototype`, `constructor` write attempts
- prototype-mutating call capture (`Object.setPrototypeOf`, `Reflect.setPrototypeOf`, `Object.defineProperty`)
- eval-sourced prototype mutation markers.

### F.2 Gadget model

Introduce compact gadget catalogue (internal table, no external dependency):

- DOM sink gadgets,
- execution gadgets,
- server-like gadgets (where observable in Node profile).

### F.3 Correlation logic

Pattern fires at higher confidence only when:

1. mutation observed, and
2. gadget-relevant sink observed within bounded call distance.

### F.4 Pattern updates

Refine `prototype_chain_execution_hijack`:

- include gadget hit metadata:
  - `gadget_family_hits`
  - `mutation_to_sink_distance`
  - `eval_source_markers`

### F.5 Tests

- positive gadget chains (client-side and Node-like).
- mutation-only control (must be lower confidence).
- sink-only control (must not trigger).

---

## WS-G: Node/Bun lifecycle script profile support (Medium)

### G.1 Profile extension

Add explicit runtime profile variants:

- `node:<vendor>:<version>:compat`
- `bun:<vendor>:<version>:compat`

Support `runtime_profile.kind` extension or `vendor`-driven branching without schema break.

### G.2 Lifecycle emulation

Add synthetic lifecycle hooks:

- `npm.preinstall`
- `npm.install`
- `npm.postinstall`
- `bun.install`

Trigger model:

- when script resembles package lifecycle context or explicit option flag.

### G.3 Telemetry

- `js.runtime.lifecycle.phase`
- `js.runtime.lifecycle.hook_calls`
- `js.runtime.lifecycle.background_attempts`

### G.4 Pattern leverage

Improve confidence for:

- `runtime_dependency_loader_abuse`
- `lotl_api_chain_execution`

when lifecycle context is confirmed.

### G.5 Tests

- lifecycle-specific unit tests in `dynamic_signals.rs`.
- detector integration for lifecycle metadata propagation.

---

## 5. PR-sized Milestones

1. **PR-1 (WS-A + WS-B base)**  
   Service Worker lifecycle stubs, realtime session telemetry, tests.

2. **PR-2 (WS-C)**  
   Taint-lite edge model + pattern confidence integration + tests.

3. **PR-3 (WS-D)**  
   Shared exfil feature extractor + scoring refactor + regression replay pack.

4. **PR-4 (WS-E)**  
   WASM static feature pass + runtime correlation + pattern refinements.

5. **PR-5 (WS-F)**  
   Prototype mutation/gadget correlation + confidence calibration updates.

6. **PR-6 (WS-G)**  
   Node/Bun lifecycle hooks + profile context propagation + integration tests.

## 6. Validation Plan

Per PR:

- `cargo test -p js-analysis --features js-sandbox --test dynamic_signals`
- `cargo test -p sis-pdf-detectors --features js-sandbox --test js_sandbox_integration`

At PR-3 and PR-6:

- random corpus sweep (`n>=100`) with unresolved-bucket tracking.
- compare:
  - unresolved executed/no-pattern count,
  - false-positive drift against benign controls,
  - timeout and telemetry saturation rates.

## 7. Acceptance Criteria

- All new patterns have:
  - positive test,
  - benign control,
  - degraded-chain confidence test,
  - detector integration test.
- No regressions in existing test suites.
- New metadata keys are additive and documented.
- Evidence quality remains non-duplicative and object-linked where available.
- Corpus unresolved bucket count decreases or remains stable with improved precision.

## 8. Risk Register

- **Risk**: FP increase from broader telemetry surfaces.  
  **Mitigation**: multi-signal thresholds + confidence demotion on partial chains.

- **Risk**: Runtime overhead from new instrumentation.  
  **Mitigation**: bounded collectors, shared feature extractors, strict caps.

- **Risk**: Profile divergence noise.  
  **Mitigation**: profile-aware confidence adjustment already in detector bridge; extend calibration tables.

- **Risk**: WASM parser abuse by malformed inputs.  
  **Mitigation**: strict bounded parser and fail-safe early exits.

## 9. Deliverables Checklist

- [ ] WS-A implemented
- [ ] WS-B implemented
- [ ] WS-C implemented
- [ ] WS-D implemented
- [ ] WS-E implemented
- [ ] WS-F implemented
- [ ] WS-G implemented
- [ ] Findings docs updated
- [ ] Query guide examples updated
- [ ] Sweep metrics updated
