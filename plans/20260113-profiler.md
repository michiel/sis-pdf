  Profiling Feature Design Suggestions

  Here's a comprehensive plan for runtime profiling without recompilation:

  1. CLI and Environment Variable Interface

  // Command-line flags
  sis scan --profile [file.pdf]
  sis scan --profile-format json [file.pdf]
  sis scan --profile-output profile.json [file.pdf]

  // Environment variables (for batch processing)
  SISPDF_PROFILE=1 sis scan [file.pdf]
  SISPDF_PROFILE_FORMAT=json sis scan [file.pdf]

  2. Profiling Data to Collect

  pub struct ProfileReport {
      // Overall timing
      pub total_duration_ms: u64,
      pub parse_duration_ms: u64,
      pub detection_duration_ms: u64,
      pub reporting_duration_ms: u64,

      // Per-detector metrics
      pub detectors: Vec<DetectorProfile>,

      // Resource usage
      pub memory: MemoryProfile,
      pub io: IoProfile,

      // Document characteristics
      pub document: DocumentProfile,
  }

  pub struct DetectorProfile {
      pub id: String,
      pub cost: String,  // "Cheap", "Moderate", "Expensive"
      pub duration_ms: u64,
      pub findings_count: usize,
      pub memory_allocated_bytes: u64,
      pub cache_hits: usize,
      pub cache_misses: usize,
  }

  pub struct MemoryProfile {
      pub peak_rss_bytes: u64,
      pub allocations: u64,
      pub deallocations: u64,
      pub bytes_allocated: u64,
  }

  pub struct IoProfile {
      pub bytes_read: u64,
      pub bytes_decoded: u64,
      pub decode_operations: usize,
  }

  pub struct DocumentProfile {
      pub file_size_bytes: u64,
      pub object_count: usize,
      pub stream_count: usize,
      pub page_count: usize,
  }

  3. Implementation Architecture

  Option A: Conditional Compilation with Feature Flag (Recommended)
  // Cargo.toml
  [features]
  default = []
  profile = ["tracing-chrome", "tikv-jemallocator"]

  // In code
  #[cfg(feature = "profile")]
  use profiling::Profiler;

  // Build both variants
  cargo build --release              # Normal build
  cargo build --release --features profile  # Profile-enabled build

  Option B: Runtime-Only (No Recompilation)
  // Always compiled in, but zero-cost when disabled
  pub struct Profiler {
      enabled: AtomicBool,
      data: Mutex<Option<ProfileData>>,
  }

  impl Profiler {
      #[inline(always)]
      pub fn record<T>(&self, name: &str, f: impl FnOnce() -> T) -> T {
          if !self.enabled.load(Ordering::Relaxed) {
              return f();  // Zero cost when disabled
          }
          let start = Instant::now();
          let result = f();
          self.record_timing(name, start.elapsed());
          result
      }
  }

  4. Integration Points

  // crates/sis-pdf-core/src/profiler.rs
  pub struct ScanProfiler {
      enabled: bool,
      start: Instant,
      detectors: Vec<DetectorTiming>,
      // ...
  }

  // In runner.rs
  pub fn run_scan_with_detectors(
      bytes: &[u8],
      options: ScanOptions,
      detectors: &[Box<dyn Detector>],
  ) -> Result<Report> {
      let profiler = ScanProfiler::new(options.profile);

      profiler.begin("parse");
      let graph = parse_pdf(bytes, parse_opts)?;
      profiler.end("parse");

      profiler.begin("detection");
      for d in detectors {
          profiler.begin_detector(d.id());
          let findings = d.run(&ctx)?;
          profiler.end_detector(d.id(), findings.len());
          // ...
      }
      profiler.end("detection");

      if options.profile {
          let report = profiler.finalize();
          output_profile(&report, &options.profile_format)?;
      }

      Ok(report)
  }

  5. Output Formats

  JSON Format (for tooling integration):
  {
    "total_duration_ms": 5620,
    "parse_duration_ms": 15,
    "detection_duration_ms": 5600,
    "detectors": [
      {
        "id": "content_first_stage1",
        "cost": "Expensive",
        "duration_ms": 5647,
        "findings_count": 299,
        "percentage": 100.5
      },
      {
        "id": "object_reference_cycle",
        "duration_ms": 12,
        "findings_count": 80,
        "percentage": 0.2
      }
    ],
    "document": {
      "file_size_bytes": 2360932,
      "object_count": 1534,
      "stream_count": 890,
      "page_count": 48
    }
  }

  Human-Readable Format:
  Scan Profile Report
  ===================
  Total Time: 5.62s

  Phase Breakdown:
    Parse:      0.015s  ( 0.3%)
    Detection:  5.600s  (99.6%)
    Reporting:  0.005s  ( 0.1%)

  Detector Performance (top 5):
    1. content_first_stage1    5647ms  299 findings  [████████████████████] 100.5%
    2. object_reference_cycle    12ms   80 findings  [                    ]   0.2%
    3. js_polymorphic_stage1      8ms    5 findings  [                    ]   0.1%
    4. metadata_analysis          5ms    1 finding   [                    ]   0.1%
    5. page_tree_anomalies        3ms    2 findings  [                    ]   0.1%

  Document Stats:
    Size:     2.3 MB
    Objects:  1534
    Streams:  890
    Pages:    48

  Recommendations:
    ⚠ content_first_stage1 took 100% of scan time
      → Consider using --fast for routine scans
      → Use --deep only when thorough analysis is needed

  Chrome Tracing Format (for flamegraphs):
  [
    {"name": "scan", "ph": "B", "ts": 0, "pid": 1, "tid": 1},
    {"name": "parse", "ph": "B", "ts": 0, "pid": 1, "tid": 1},
    {"name": "parse", "ph": "E", "ts": 15000, "pid": 1, "tid": 1},
    {"name": "detection", "ph": "B", "ts": 15000, "pid": 1, "tid": 1},
    {"name": "content_first_stage1", "ph": "B", "ts": 15000, "pid": 1, "tid": 1},
    {"name": "content_first_stage1", "ph": "E", "ts": 5662000, "pid": 1, "tid": 1},
    // ...
  ]
  View in Chrome: chrome://tracing

  6. Advanced Features

  Flamegraph Integration:
  # Generate flamegraph directly
  sis scan --profile --profile-format flamegraph -o profile.svg [file.pdf]

  # Or export for inferno
  sis scan --profile --profile-format folded -o profile.folded [file.pdf]
  inferno-flamegraph < profile.folded > flamegraph.svg

  Continuous Profiling:
  # Profile a corpus
  for pdf in corpus/*.pdf; do
    sis scan --profile --profile-format json "$pdf" > "profiles/$(basename $pdf).json"
  done

  # Aggregate analysis
  sis analyze-profiles profiles/*.json > summary.md

  Detector Recommendation Engine:
  // Analyze profile and suggest optimization
  pub fn analyze_profile(profile: &ProfileReport) -> Vec<Recommendation> {
      let mut recommendations = Vec::new();

      for detector in &profile.detectors {
          if detector.duration_ms > 1000 && detector.cost != "Expensive" {
              recommendations.push(Recommendation {
                  level: "warning",
                  detector: detector.id.clone(),
                  message: format!(
                      "Detector '{}' took {}ms but is marked as {}. Consider reclassifying as Expensive.",
                      detector.id, detector.duration_ms, detector.cost
                  ),
              });
          }

          if detector.findings_count == 0 && detector.duration_ms > 100 {
              recommendations.push(Recommendation {
                  level: "info",
                  detector: detector.id.clone(),
                  message: format!(
                      "Detector '{}' took {}ms but found nothing. Consider early bailout optimizations.",
                      detector.id, detector.duration_ms
                  ),
              });
          }
      }

      recommendations
  }

  7. Memory Profiling Integration

  // Optional jemalloc integration for detailed memory profiling
  #[cfg(all(feature = "profile", not(target_env = "msvc")))]
  #[global_allocator]
  static ALLOC: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;

  // Enable heap profiling
  MALLOC_CONF=prof:true sis scan --profile [file.pdf]

  8. Recommended Implementation Plan

  Phase 1: Basic Timing (Already partially done!)
  - ✅ Add Instant timing to runner.rs (done in this commit)
  - Add --profile flag to CLI
  - Output simple text report with detector timings

  Phase 2: Structured Output
  - Define ProfileReport struct
  - Implement JSON output format
  - Add document statistics

  Phase 3: Advanced Features
  - Chrome tracing format for flamegraphs
  - Memory profiling integration
  - Recommendation engine

  Phase 4: Tooling
  - Profile aggregation for corpus analysis
  - Visualization tools
  - CI/CD integration for performance regression detection

  9. Example Usage Scenarios

  # Quick profiling during development
  sis scan --profile test.pdf

  # Generate data for analysis
  sis scan --profile --profile-format json --profile-output profile.json test.pdf

  # Batch corpus profiling
  find corpus/ -name "*.pdf" -exec sis scan --profile --profile-output {}.profile {} \;

  # CI performance regression test
  sis scan --profile --profile-format json test.pdf > new-profile.json
  diff <(jq '.total_duration_ms' baseline-profile.json) <(jq '.total_duration_ms' new-profile.json)

  This design allows profiling to be:
  - Zero-cost when disabled (with Option B)
  - No recompilation needed (enabled via flags)
  - Rich data export (JSON, flamegraphs)
  - Actionable insights (recommendations)
  - CI/CD friendly (regression detection)

