# egui WASM feasibility: browser-native PDF analysis

Date: 2026-02-15
Status: Proposed
Owner: new crate `sis-pdf-gui` + feature-flag changes across workspace

## 1) Objective

Establish feasibility of compiling the sis analysis pipeline to WebAssembly and running it in a browser with an egui-based minimal UI, with no backend server. The user drops a PDF, analysis runs entirely client-side, and findings are displayed in the browser.

This plan covers feasibility validation and a minimal UI only. ML scoring is out of scope.

## 2) Feasibility assessment

### 2.1 Dependency audit

Every dependency in the analysis path has been audited for `wasm32-unknown-unknown` compatibility.

**Parser crate (`sis-pdf-pdf`) -- CLEAN:**

All dependencies are pure Rust with no platform constraints:
- anyhow, base64, flate2, memchr, serde, tracing, thiserror, weezl
- No `std::fs`, no `std::thread`, no `std::net` usage in source.

**Detector crate (`sis-pdf-detectors`) -- CLEAN:**

All dependencies are pure Rust:
- anyhow, hex, sha2, base64, flate2, roxmltree, lzma-rust2, tracing
- Internal crate deps: sis-pdf-core, sis-pdf-pdf, js-analysis, font-analysis, image-analysis
- No `std::fs`, no `std::thread` usage in source.

**JS analysis crate (`js-analysis`) -- COMPATIBLE:**

- Boa engine (parser, AST, interner, engine, GC) explicitly supports WASM. Boa ships an official WASM playground.
- `std::fs` usage is only in `bin/js-corpus-harness.rs` and `corpus_regression.rs` (test/tool code, not library).
- `std::thread::spawn` is used in `dynamic.rs:4301` for sandbox timeout enforcement. This needs a feature gate (see Section 3.2).

**Font analysis crate (`font-analysis`) -- COMPATIBLE:**

- skrifa, ttf-parser, allsorts are all pure Rust with confirmed WASM support.
- All three are behind the `dynamic` feature flag already.
- `std::fs` usage is only in `signatures.rs:627` inside a `#[cfg(test)]` block.
- `std::thread::spawn` is used in `lib.rs:224` for timeout enforcement. Needs a feature gate (see Section 3.2).

**Image analysis crate (`image-analysis`) -- COMPATIBLE:**

- All decoders (hayro-jbig2, hayro-jpeg2000, jpeg-decoder, png, tiff) are pure Rust.
- All behind individual feature flags already.
- No `std::fs`, no `std::thread` usage.

**Core crate (`sis-pdf-core`) -- NEEDS WORK:**

Three categories of incompatibility:

| Issue | Files | Impact |
|---|---|---|
| `std::fs` | cache.rs, config.rs, ml_models.rs, ml_inference.rs, filter_allowlist.rs, explainability.rs, temporal.rs | Cannot read files from WASM |
| `rayon` | runner.rs:167-168 | rayon does not compile to `wasm32-unknown-unknown` |
| `std::time::Instant` | Various (if using `Instant::now()`) | `Instant` panics on WASM in some contexts; use `web_time` or feature-gate |

**ML graph crate (`sis-pdf-ml-graph`) -- EXCLUDED:**

Out of scope for this plan. Already optional behind `ml-graph` feature flag on `sis-pdf-core`.

### 2.2 Summary

| Crate | WASM ready | Changes needed |
|---|---|---|
| `sis-pdf-pdf` | Yes | None |
| `sis-pdf-detectors` | Yes | None (propagates feature flags from deps) |
| `js-analysis` | Yes | Feature-gate `std::thread` timeout in dynamic.rs |
| `font-analysis` | Yes | Feature-gate `std::thread` timeout in lib.rs |
| `image-analysis` | Yes | None |
| `sis-pdf-core` | Partial | Feature-gate `std::fs` callers and `rayon` |
| `sis-pdf-ml-graph` | N/A | Excluded via existing feature flag |

The parser and all detectors compile to WASM without changes. The core crate needs feature-gated alternatives for filesystem, threading, and parallelism.

## 3) Required changes to existing crates

### 3.1 `sis-pdf-core`: rayon parallelism gate

`runner.rs:166-168` uses rayon for parallel detector execution. Add a feature flag:

```toml
# crates/sis-pdf-core/Cargo.toml
[features]
parallel = ["rayon"]

[dependencies]
rayon = { version = "1.10", optional = true }
```

In `runner.rs`, branch on the feature:

```rust
let mut findings: Vec<Finding> = if ctx.options.parallel {
    #[cfg(feature = "parallel")]
    {
        // existing rayon pool logic
    }
    #[cfg(not(feature = "parallel"))]
    {
        // sequential fallback: detectors.iter().filter(...).filter_map(...)
    }
} else {
    // existing sequential path
};
```

The sequential path already exists in `runner.rs` for the `!ctx.options.parallel` branch. The feature gate reuses it when rayon is unavailable.

### 3.2 `js-analysis` and `font-analysis`: thread timeout gate

Both crates use `std::thread::spawn` solely for timeout enforcement around dynamic analysis:
- `js-analysis/src/dynamic.rs:4301`
- `font-analysis/src/lib.rs:224`

These are already behind feature flags (`js-sandbox` and `dynamic` respectively). For WASM, disable these features. Static analysis (JS AST parsing, font structure validation, signature matching) works without them.

No code changes needed if the WASM build simply omits `js-sandbox` and `font-dynamic` features. If dynamic analysis is wanted on WASM later, the timeout mechanism can be replaced with `wasm-bindgen-futures` + `setTimeout`, but that is out of scope.

### 3.3 `sis-pdf-core`: filesystem usage gate

The `std::fs` callers in core are all in modules that are irrelevant to a WASM analysis session:

| Module | Purpose | WASM relevance |
|---|---|---|
| `cache.rs` | Disk-based scan result cache | None -- no disk in browser |
| `config.rs` | TOML config file loading | None -- config comes from UI |
| `ml_models.rs` | ML model file loading | None -- ML excluded |
| `ml_inference.rs` | ML inference config loading | None -- ML excluded |
| `filter_allowlist.rs` | Load filter allowlist from file | None -- embed or omit |
| `explainability.rs` | Persist/load explanation reports | None -- render in UI |
| `temporal.rs` | Read PDF bytes from path | None -- bytes come from JS |

Strategy: guard these modules behind a `filesystem` feature (default-on for native, off for WASM).

```toml
# crates/sis-pdf-core/Cargo.toml
[features]
default = ["parallel", "filesystem"]
parallel = ["rayon"]
filesystem = []
```

Each `std::fs` call site gets `#[cfg(feature = "filesystem")]`. Functions that load from paths get companion functions that accept `&[u8]` or `&str` (most already exist -- `ScanContext::new()` takes `&[u8]`).

The scan pipeline itself (`ScanContext::new()`, `run_detectors()`, `correlate_findings()`) does not use `std::fs` at all. It operates on `&[u8]` throughout.

### 3.4 `std::time::Instant` on WASM

`Instant::now()` panics on `wasm32-unknown-unknown` in some Rust versions. Two options:
1. Use the `web-time` crate (drop-in replacement, uses `performance.now()` on WASM).
2. Feature-gate profiling/timing code.

Recommendation: add `web-time` as a dependency on WASM targets via `[target.'cfg(target_arch = "wasm32")'.dependencies]`. Alias it to `Instant` with a conditional import. This is a minimal, well-tested approach.

## 4) New crate: `sis-pdf-gui`

### 4.1 Crate structure

```
crates/sis-pdf-gui/
  Cargo.toml
  src/
    lib.rs          -- wasm-bindgen entry point + file drop handler
    app.rs          -- eframe::App implementation
    panels/
      drop_zone.rs  -- file drop UI
      summary.rs    -- finding summary panel
      findings.rs   -- findings table with sort/filter
      detail.rs     -- single finding detail view
      chains.rs     -- chain visualisation (text-based)
```

### 4.2 Dependencies

```toml
[package]
name = "sis-pdf-gui"
version.workspace = true
edition = "2021"

[dependencies]
eframe = { version = "0.31", default-features = false, features = ["wgpu", "web_screen_reader"] }
egui = "0.31"
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["File", "FileReader", "DragEvent", "DataTransfer"] }
js-sys = "0.3"
serde = { workspace = true }
serde_json = { workspace = true }
tracing = { workspace = true }

# Analysis pipeline (no filesystem, no parallelism, no ML)
sis-pdf-core = { path = "../sis-pdf-core", default-features = false }
sis-pdf-pdf = { path = "../sis-pdf-pdf" }
sis-pdf-detectors = { path = "../sis-pdf-detectors", default-features = false, features = ["js-ast"] }

[lib]
crate-type = ["cdylib"]
```

Feature selection rationale:
- `sis-pdf-core` with `default-features = false` -- excludes `parallel` and `filesystem`.
- `sis-pdf-detectors` with `features = ["js-ast"]` -- includes JS static analysis (Boa parser/AST), excludes `js-sandbox` (thread-dependent) and `font-dynamic` (thread-dependent).
- Static font analysis (signature matching, structure validation) works without the `dynamic` feature.
- All image decoders are included (they have no platform constraints).

### 4.3 WASM entry point

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    // Set up panic hook for readable WASM errors
    console_error_panic_hook::set_once();
    // Start eframe
    let web_options = eframe::WebOptions::default();
    wasm_bindgen_futures::spawn_local(async {
        eframe::WebRunner::new()
            .start("sis_canvas", web_options, Box::new(|cc| Ok(Box::new(app::SisApp::new(cc)))))
            .await
            .expect("failed to start eframe");
    });
    Ok(())
}
```

### 4.4 Analysis flow

1. User drops a PDF file onto the browser canvas.
2. JavaScript `FileReader` reads the file bytes via `web-sys`.
3. Bytes are passed to the Rust analysis pipeline:
   - `sis_pdf_pdf::parse_pdf(&bytes)` -- build object graph.
   - `ScanContext::new(&bytes, graph, options)` -- create analysis context.
   - `run_detectors(&ctx, &detectors)` -- run all detectors sequentially.
   - `correlate_findings(&mut findings, &ctx)` -- build chains and composites.
4. Results are stored in the `SisApp` state.
5. egui renders the findings.

Analysis runs synchronously on the main thread for the minimal UI. If this causes noticeable UI freezing (>200ms), a follow-up can move analysis to a Web Worker via `wasm-bindgen-rayon` or message passing. Typical triage completes in <50ms, so this is unlikely to be an issue.

### 4.5 Minimal UI panels

**Drop zone (initial state):**
- Centred drop target with instructions.
- File name and size displayed after drop.
- Analysis progress indicator (for deep analysis on large files).

**Summary panel (after analysis):**
- File metadata: pages, version, encrypted, file size.
- Finding count by severity (critical/high/medium/low/info).
- Chain count.
- Attack surface coverage summary.

**Findings table:**
- Columns: severity, confidence, kind, attack surface, description.
- Sort by column header click.
- Filter by severity (toggle buttons).
- Click row to open detail view.

**Finding detail panel:**
- Full finding metadata.
- Evidence spans with object references.
- Reader impact annotations (Acrobat/PDFium/Preview).
- Related chain context if the finding participates in a chain.

**Chain panel:**
- Text-based chain display: trigger -> action -> payload.
- Severity and confidence for each chain.
- Linked finding references.

No stream decoding, no interactive query REPL, no explain rendering in the minimal UI. These are follow-up features.

## 5) Build and deployment

### 5.1 Build toolchain

```bash
# Install wasm target
rustup target add wasm32-unknown-unknown

# Install trunk for dev server and WASM bundling
cargo install trunk

# Build
cd crates/sis-pdf-gui
trunk build --release

# Dev server with hot reload
trunk serve
```

### 5.2 `index.html`

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>sis - PDF security analyser</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="sis_canvas"></canvas>
</body>
</html>
```

### 5.3 Output

Trunk produces a `dist/` directory containing:
- `index.html`
- `sis-pdf-gui_bg.wasm` (the compiled WASM module)
- `sis-pdf-gui.js` (generated JS glue)

This can be served from any static file host (GitHub Pages, S3, Netlify) with no backend.

### 5.4 WASM size budget

Expected uncompressed WASM binary size estimate:

| Component | Estimated size |
|---|---|
| sis-pdf-pdf (parser) | ~200 KB |
| sis-pdf-core (analysis engine) | ~400 KB |
| sis-pdf-detectors (40+ detectors) | ~600 KB |
| js-analysis (Boa AST, no sandbox) | ~1.5 MB |
| font-analysis (static only) | ~300 KB |
| image-analysis (all decoders) | ~400 KB |
| egui + eframe (WASM renderer) | ~1.0 MB |
| Total uncompressed | ~4.4 MB |
| Brotli compressed (typical 4x) | ~1.1 MB |

This is within acceptable range for a browser application. The Boa engine is the largest contributor. If size becomes a concern, `js-ast` can be made optional in the GUI build.

## 6) Implementation plan

### PR-W1: Feature-gate `sis-pdf-core` for WASM compatibility

Changes:
1. Make `rayon` optional behind `parallel` feature in `sis-pdf-core/Cargo.toml`.
2. Add `#[cfg(feature = "parallel")]` / `#[cfg(not(feature = "parallel"))]` branches in `runner.rs`.
3. Add `filesystem` feature flag; guard `std::fs` call sites in cache.rs, config.rs, ml_models.rs, ml_inference.rs, filter_allowlist.rs, explainability.rs, temporal.rs.
4. Add `web-time` dependency for `wasm32` target; conditional import for `Instant`.
5. Ensure `default = ["parallel", "filesystem"]` so native builds are unchanged.

Tests:
1. `cargo test` passes with default features (no regression).
2. `cargo check -p sis-pdf-core --no-default-features` compiles.
3. `cargo check -p sis-pdf-core --no-default-features --target wasm32-unknown-unknown` compiles.

Validation gate: the core crate compiles for `wasm32-unknown-unknown` with `--no-default-features`.

### PR-W2: Verify full pipeline compiles to WASM

Changes:
1. Add `sis-pdf-gui` crate to workspace with minimal `lib.rs` (wasm-bindgen entry point, no UI yet).
2. Wire dependencies: `sis-pdf-core` (no-default-features), `sis-pdf-pdf`, `sis-pdf-detectors` (js-ast only).
3. Add a `pub fn analyze(bytes: &[u8]) -> String` function that runs the full pipeline and returns JSON findings.
4. Add a `tests/` integration test that calls `analyze()` with a fixture PDF and asserts findings are produced.

Tests:
1. `cargo check -p sis-pdf-gui --target wasm32-unknown-unknown` compiles.
2. Native integration test passes: `analyze()` on a fixture returns valid JSON with expected finding kinds.
3. WASM integration test (via `wasm-pack test --headless --chrome`): `analyze()` on a small fixture returns findings.

Validation gate: the full analysis pipeline executes in a browser WASM context and produces correct findings.

### PR-W3: Minimal egui UI

Changes:
1. Add eframe app structure with drop zone, summary, findings table, detail panel, chain panel.
2. Wire file drop via `web-sys` FileReader to `analyze()`.
3. Add `trunk` build configuration (`Trunk.toml`, `index.html`).
4. Style with egui defaults (no custom theming for now).

Tests:
1. `trunk build --release` produces a working `dist/` directory.
2. Manual browser test: drop a PDF, verify findings render.
3. Findings table sort and severity filter work.
4. Chain panel displays chain structure for a fixture with known chains.

Validation gate: a user can open the page in a browser, drop a PDF, and see analysis results with no backend.

## 7) What is excluded from the minimal UI

1. ML scoring (excluded at dependency level).
2. JS sandbox / dynamic analysis (thread-dependent, excluded via feature flags).
3. Dynamic font analysis (thread-dependent, excluded via feature flags).
4. Stream decoding / hex dump viewer.
5. Interactive query REPL.
6. Explain rendering.
7. Batch analysis / multi-file comparison.
8. Report generation / export.
9. Custom theming or branding.

All of these are follow-up features that can be added incrementally once feasibility is confirmed.

## 8) Risks and mitigations

1. **Risk:** Boa AST parsing is slow on WASM for large JS payloads.
   Mitigation: the `js-ast` feature runs static pattern matching and AST analysis, not full execution. It is bounded by the existing JS size limits in `js-analysis`. If slow, add a WASM-specific timeout via `setTimeout` or cap JS analysis size more aggressively.

2. **Risk:** WASM binary too large for acceptable load times.
   Mitigation: Brotli compression typically achieves 4x reduction. If still too large, make `js-ast` and image decoders optional in the GUI build. Core analysis (parser + structure + action detectors) alone would be ~1 MB compressed.

3. **Risk:** Analysis of large PDFs (>10 MB) causes browser tab OOM or UI freeze.
   Mitigation: add a file size cap in the drop handler (e.g. 50 MB). For the minimal UI, synchronous analysis is acceptable because typical triage is <50ms. If large-file support is needed later, offload to a Web Worker.

4. **Risk:** `lopdf` does not compile to WASM.
   Mitigation: lopdf is pure Rust and has no C dependencies. If it has a hidden WASM incompatibility, it is used only as the secondary parser in `sis-pdf-core/src/diff.rs`. It can be feature-gated out for WASM without losing primary analysis capability. PR-W1 will validate this.

5. **Risk:** Feature-gating `rayon` and `filesystem` breaks native builds.
   Mitigation: both features are default-on. `cargo test` with default features is the first validation gate in PR-W1.

6. **Risk:** `std::time::Instant` panics at runtime on WASM even if it compiles.
   Mitigation: `web-time` crate provides a drop-in replacement that uses `performance.now()`. Conditional import via `#[cfg(target_arch = "wasm32")]`.

## 9) Exit criteria

1. `cargo check --target wasm32-unknown-unknown` succeeds for `sis-pdf-gui` and all transitive dependencies.
2. `wasm-pack test --headless --chrome` passes an integration test that analyses a fixture PDF in a browser context.
3. `trunk build --release` produces a deployable `dist/` with WASM module under 2 MB compressed.
4. A user can open the page, drop a PDF, and see: file metadata, finding counts by severity, a sortable/filterable findings table, finding detail on click, and chain summaries.
5. Native `cargo test` passes across the entire workspace with no regressions from feature-flag changes.
