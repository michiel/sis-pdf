# Next Implementation Plan: JS Sandbox High/Medium Feasibility Items

Date: 2026-02-11
Status: Implemented
Scope: `crates/js-analysis`, `crates/sis-pdf-detectors`, docs updates

## 1. Objective

Implement the highest-value modernisation work identified in `docs/research/20260211-js-path.md`, focused on:

- improved runtime fidelity for modern web malware behaviours,
- stronger source-to-sink intent attribution,
- deeper WASM and prototype-abuse signal quality,
- optional Node/Bun lifecycle coverage for supply-chain scripts.

Out of scope for this plan:

- global payload limit increase to 50 MiB,
- speculative agentic malware attribution heuristics.

## 2. Guardrails and Constraints

- No `unsafe` and no `unwrap` usage.
- Preserve deterministic output under identical input/options.
- Preserve bounded resource usage (time, loops, recursion, telemetry cardinality).
- No real network/filesystem side-effects from stubs.
- Maintain stable query/output schema; additive metadata keys only.
- New lifecycle phases and profile variants must not break `ProfileDivergenceSummary` calculations in `js_sandbox.rs`; divergence ratios must remain meaningful when new phases or profiles are added.

## 3. Workstream Summary (MECE)

1. **WS-A**: Service Worker lifecycle emulation and persistence telemetry.
2. **WS-B**: WebSocket/WebRTC deep telemetry and session-level exfil signal extraction.
3. **WS-C**: Dynamic taint-lite source-to-sink correlation.
4. **WS-D**: Exfil URL/domain feature expansion and scoring refinement.
5. **WS-E**: WASM bytecode and runtime combined signal model.
6. **WS-F**: Prototype pollution gadget correlation model.
7. **WS-G**: Node/Bun lifecycle script profile support.

---

## 3.1 Execution Start Gate

Before starting PR-1a, complete and record:

- baseline artefact at `plans/20260211-next-001-baseline.json`,
- current pass counts for the JS sandbox and detector suites listed in section 6,
- unresolved/false-positive/timeout/saturation baseline from the random sweep.

Start condition:

- baseline artefact exists and is referenced in the first implementation PR notes.

Stop condition for each PR:

- targeted test suites pass,
- no schema-breaking metadata changes,
- one short sweep note appended under section 9 checklist.

## 4. Detailed Technical Plan

## WS-A: Service Worker lifecycle emulation and persistence telemetry (High)

### A.0 Current state

The `service_worker_persistence_abuse` pattern already exists in `dynamic.rs`. It currently fires on:

- `navigator.serviceWorker.register` / `unregister` calls,
- combined with cache or storage activity.

It does **not** emulate actual lifecycle phases (install/activate/fetch/push/sync), does not capture event handler registrations, and does not differentiate registration-only from active lifecycle abuse.

Stubs exist for `navigator.serviceWorker.register` in `register_profiled_stubs()` but return simple values without triggering lifecycle progression.

**Delta**: Add lifecycle phase orchestration, expanded stubs, richer telemetry, and refine the existing pattern to require lifecycle evidence.

### A.1 Runtime surface

Extend browser-like stubs in `crates/js-analysis/src/dynamic.rs`:

- `navigator.serviceWorker.register/getRegistration/getRegistrations/ready/update`
- `ServiceWorkerRegistration.update/unregister/showNotification`
- synthetic worker event handlers:
  - `self.addEventListener('install'|'activate'|'fetch'|'push'|'sync', ...)`
  - `clients.claim`, `skipWaiting`

### A.2 Orchestration changes

Add synthetic lifecycle phases (internal only; keep user-facing phase model stable):

- `sw_install`
- `sw_activate`
- `sw_fetch`
- `sw_push`
- `sw_sync`

These phases are **not** new `RuntimePhase` enum variants. They are internal micro-phases within the existing phase execution loop, gated by a `worker_registration_observed` flag on `SandboxLog`.

Execution order:

1. existing page phases (`open`, `idle`, `click`, `form`)
2. worker lifecycle micro-phases when worker registration is observed.

Design sketch:

```
fn run_sandbox_phases(script, options) -> DynamicOutcome:
    log = SandboxLog::new()
    flow = ExecutionFlow::new()

    // --- standard page phases ---
    for phase in [Open, Idle, Click, Form]:
        execute_phase(script, phase, &mut log, &mut flow)

    // --- conditional SW lifecycle micro-phases ---
    if log.worker_registration_observed:
        for sw_phase in [sw_install, sw_activate, sw_fetch, sw_push, sw_sync]:
            execute_sw_micro_phase(script, sw_phase, &mut log, &mut flow)
            // SandboxLog accumulates across all phases (no reset)
            // Each micro-phase invokes the registered event handler if present

    // --- pattern analysis runs once over the full accumulated log ---
    observations = analyze_patterns(&flow, &log)
    ...
```

Key invariants:

- `SandboxLog` accumulates across all phases including micro-phases (no per-phase reset).
- Micro-phases reuse the same `ExecutionFlow` context so call distance calculations span the full execution.
- Existing patterns that count calls or check phase presence are unaffected because micro-phase calls are appended to the same `log.calls` vec.
- Phase timeout applies per micro-phase; total wall-clock timeout still governs the entire run.

### A.3 Telemetry additions

Add metadata keys under `js.runtime.service_worker.*`:

- `registration_calls`
- `update_calls`
- `event_handlers_registered`
- `lifecycle_events_executed`
- `cache_calls`
- `indexeddb_calls`

### A.4 Pattern and finding updates

Refine existing `service_worker_persistence_abuse`:

- require lifecycle/event evidence rather than only registration + cache.
- confidence uplift when fetch/push/sync event path executes.

Detector:

- keep kind `js_runtime_service_worker_persistence`.
- add explicit lifecycle evidence fields in finding metadata.

### A.5 Divergence impact

New micro-phases append calls to `SandboxLog` which feeds into `ProfileDivergenceSummary`. Since micro-phases only trigger when worker registration is observed, profiles that do not register workers see no change. Profiles that do register workers will have higher call counts; the divergence ratio calculation must account for this by normalising against the per-profile call total (already the case in the existing `profile_calls_ratio` computation).

### A.6 Tests

- `crates/js-analysis/tests/dynamic_signals.rs`: positive/negative cases for registration-only vs full lifecycle.
- integration: ensure finding emitted only with lifecycle criteria.
- regression: deterministic phase ordering with and without worker registration.

---

## WS-B: WebSocket/WebRTC deep telemetry and session-level exfil signals (High)

### B.0 Current state

The `covert_realtime_channel_abuse` pattern already exists in `dynamic.rs`. It currently fires on:

- `RTCPeerConnection.createDataChannel` + `RTCDataChannel.send` calls,
- `WebSocket.send` calls,
- combined with encoding activity (btoa, encodeURIComponent).

It does **not** differentiate setup-only from active transfer, does not track session counts or unique targets, and does not capture average payload lengths or channel type breakdowns.

Stubs exist for `WebSocket` constructor and `RTCPeerConnection` in `register_profiled_stubs()`.

**Delta**: Add session-level telemetry counters, expand stubs to capture constructor URLs and protocol details, and refine the pattern to calibrate confidence by chain completeness.

### B.1 Runtime surface

Expand stubs:

- `new WebSocket(url, protocols?)` constructor-level capture.
- `WebSocket.send/close`
- `RTCPeerConnection` session methods:
  - `createOffer/createAnswer/setLocalDescription/setRemoteDescription/addIceCandidate`
- `RTCDataChannel.send/close`

### B.2 Telemetry model

Add session-oriented telemetry, accumulated on `SandboxLog` as new counter fields:

- `js.runtime.realtime.session_count`
- `js.runtime.realtime.unique_targets`
- `js.runtime.realtime.send_count`
- `js.runtime.realtime.avg_payload_len`
- `js.runtime.realtime.channel_types` (`websocket`, `rtc_datachannel`)

### B.3 Behaviour refinements

Refine `covert_realtime_channel_abuse`:

- differentiate setup-only vs active transfer.
- confidence calibration by chain completeness:
  - setup + send + encoding + repeated send => high.

### B.4 Tests

- unit: setup-only should not trigger high-confidence chain.
- unit: repeated encoded sends triggers pattern.
- integration: finding metadata includes realtime session keys.

---

## WS-C: Dynamic taint-lite source-to-sink correlation (High)

### C.0 Current state

No source-to-sink correlation exists today. The following patterns rely on co-occurrence of source and sink calls within the same `SandboxLog` but have no notion of call distance or ordering:

- `clipboard_session_hijack_behaviour` -- checks clipboard read + session source + network sink presence.
- `chunked_data_exfil_pipeline` -- checks append + encode + send loop presence.
- `credential_harvest_form_emulation` -- checks form field reads + network sink presence.

**Delta**: Add a new `TaintEdge` tracking subsystem to `SandboxLog`, implement source/sink event capture, positional correlation, and integrate edges into the three patterns above for confidence uplift.

### C.1 Sub-stage 1: Source and sink event capture

Record source events when the following APIs are accessed (append to `SandboxLog.taint_sources: Vec<TaintEvent>`):

- `document.cookie`
- `localStorage.getItem/sessionStorage.getItem`
- form field reads (`getField`, DOM value reads)
- clipboard reads

Record sink events (append to `SandboxLog.taint_sinks: Vec<TaintEvent>`):

- execution sinks: `eval`, `Function`
- network sinks: `fetch`, `sendBeacon`, `WebSocket.send`, `RTCDataChannel.send`, `XMLHTTP.send`

Each `TaintEvent` records:

```rust
struct TaintEvent {
    kind: TaintEventKind,     // enum: Cookie, LocalStorage, SessionStorage, FormField, Clipboard, Eval, Function, Fetch, SendBeacon, WebSocketSend, ...
    call_index: usize,        // position in log.calls
    phase: RuntimePhase,      // which phase the event occurred in
}
```

### C.2 Sub-stage 2: Edge correlation model

After all phases complete (including SW micro-phases if applicable), correlate sources and sinks:

```rust
struct TaintEdge {
    source: TaintEventKind,
    sink: TaintEventKind,
    call_distance: usize,     // sink.call_index - source.call_index
    phase_source: RuntimePhase,
    phase_sink: RuntimePhase,
}
```

Correlation rule:

- For each source event, find all subsequent sink events within `MAX_TAINT_CALL_DISTANCE` (default: 512 calls).
- Emit one `TaintEdge` per (source, sink) pair.
- Cap total edges at `MAX_TAINT_EDGES` (default: 64) to preserve bounded resource usage.

Storage: `SandboxLog.taint_edges: Vec<TaintEdge>` (new field, capped at `MAX_TAINT_EDGES`).

### C.3 Sub-stage 3: Pattern integration

Expose aggregated metadata:

- `js.runtime.taint.edges` (count)
- `js.runtime.taint.source_types` (comma-separated unique source kinds)
- `js.runtime.taint.sink_types` (comma-separated unique sink kinds)
- `js.runtime.taint.max_call_distance` (max observed distance)

Use edges to strengthen confidence for:

- `clipboard_session_hijack_behaviour` -- uplift when clipboard source -> network sink edge exists.
- `chunked_data_exfil_pipeline` -- uplift when storage/form source -> network sink edge exists.
- `credential_harvest_form_emulation` -- uplift when form source -> network sink edge exists.

Integration with `calibrate_chain_signal`: taint edge presence adds +1 to `component_hits` for these patterns, allowing the existing calibration function to raise confidence naturally.

### C.4 Tests

- positive: cookie/storage/form/clipboard to send/eval.
- negative: source without sink and sink without source.
- determinism: stable edge ordering and serialisation.
- bounds: verify MAX_TAINT_EDGES cap is respected with pathological input.

---

## WS-D: Exfil URL/domain feature expansion and scoring refinement (High)

### D.0 Current state

The `covert_beacon_exfil` pattern already exists and uses inline threshold checks for:

- `long_query_urls` (query length > threshold)
- `deep_label_domains` (subdomain label count)
- `high_entropy_domains` (entropy calculation)
- `encoded_url_args` (percent-encoded tokens)
- `dense_query_key_urls` (key-value density)

The `chunked_data_exfil_pipeline` pattern checks for append + encode + send loops.

Both patterns use ad hoc threshold constants. There is no shared URL/domain feature extraction utility.

**Delta**: Extract a shared `ExfilUrlFeatures` struct and scoring function, replace inline thresholds with a weighted score table, and apply to both patterns.

### D.1 Feature extractor

Centralise URL/domain feature extraction as a utility function in `dynamic.rs`:

```rust
struct ExfilUrlFeatures {
    query_length: usize,
    key_value_density: f64,
    label_depth: usize,
    subdomain_entropy: f64,
    query_entropy: f64,
    encoded_token_count: usize,   // %2f, %3d, %2b, base64-like chunks
    target_repetition: usize,     // same target across calls/phases
}
```

- query length, key-value density, label depth
- entropy measures for subdomain and query
- encoded token presence (`%2f`, `%3d`, `%2b`, base64-like chunks)
- target repetition across calls/phases

### D.2 Scoring model

Replace ad hoc thresholds with a weighted score table defined as a constant array:

```rust
const EXFIL_SCORE_WEIGHTS: &[(&str, f64)] = &[
    ("network_sink_present", 1.0),
    ("encoded_payload_indicator", 1.5),
    ("repeated_target_cadence", 2.0),
    ("high_entropy_query", 1.5),
    ("high_density_query", 1.0),
    ("deep_label_domain", 1.0),
];
```

Weights are manually calibrated against existing test fixtures and the corpus sweep baseline (see section 6). Score table lives as a module-level constant in `dynamic.rs`.

Score bands map to confidence via `calibrate_chain_signal`:

- Low confidence: score < 2.0 (weak single-signal)
- Probable: score 2.0..4.0 (multi-signal)
- Strong: score >= 4.0 (multi-signal with repeated send behaviour)

Migration strategy: existing patterns (`covert_beacon_exfil`, `chunked_data_exfil_pipeline`) switch to calling the shared scorer. Existing test fixtures must produce identical or higher confidence after the switch; any regression is a blocking test failure.

### D.3 Pattern integration

Apply to:

- `covert_beacon_exfil`
- `chunked_data_exfil_pipeline`

### D.4 Tests

- table-driven test vectors for score bands.
- malicious fixture replays where previous false negatives existed.
- regression: existing test fixtures must not drop in confidence.

---

## WS-E: WASM bytecode + runtime combined model (Medium)

### E.0 Current state

Two WASM-related patterns exist in `dynamic.rs`:

- `wasm_loader_staging` -- fires on `WebAssembly.instantiate` / `WebAssembly.compile` calls.
- `wasm_memory_unpacker_pipeline` -- fires on `WebAssembly.Memory` + unpack calls + eval/Function chain.

Static analysis has `js.wasm_mining` detection (byte pattern matching for known mining libraries).

Stubs exist for `WebAssembly.instantiate`, `WebAssembly.compile`, `WebAssembly.Module`, `WebAssembly.Memory`, `WebAssembly.Table`, `WebAssembly.Instance` in `register_webassembly_stub()`.

**Delta**: Add a bounded WASM binary pre-pass parser (new module), correlate static byte features with runtime calls, and refine existing patterns with combined scoring.

### E.1 Static byte feature pre-pass

Add a new internal module `wasm_features.rs` in `crates/js-analysis/src/` for WASM binary analysis.

For likely WASM binaries or embedded buffers:

- preamble detection (`\0asm`)
- section map extraction (type/import/function/table/memory/export)
- suspicious import names (`env.eval`, `env.fetch`, dynamic dispatch shims)
- memory/table density and anomalous section sizes

WASM blob identification: scan `SandboxLog` for `ArrayBuffer` or `Uint8Array` arguments passed to `WebAssembly.instantiate`/`compile`. Also scan static analysis byte content for `\0asm` preamble.

Bounded parsing with concrete limits:

- maximum WASM blob size: 1 MiB (skip larger blobs with a telemetry note).
- maximum sections: 32 (early exit if exceeded).
- maximum parse time: reuse phase timeout (no separate budget).
- early exit on malformed data (invalid section IDs, length overflows).
- all reads via checked slicing; no index arithmetic without bounds validation.

### E.2 Runtime correlation

Correlate static features with runtime calls:

- `WebAssembly.instantiate/compile/Module/Memory/Table`
- decode/unpack primitives
- dynamic execution sinks

### E.3 Pattern updates

Refine:

- `wasm_loader_staging`
- `wasm_memory_unpacker_pipeline`

Add metadata:

- `js.runtime.wasm.static.suspicious_imports`
- `js.runtime.wasm.static.section_count`
- `js.runtime.wasm.static.memory_sections`
- `js.runtime.wasm.correlation_score`

### E.4 Tests

- fixture-like byte arrays for benign vs suspicious imports.
- regression for malformed modules (must fail safely, no panic).
- oversized blobs (> 1 MiB) must be skipped gracefully.
- pattern confidence uplift only when static+runtime correlate.

---

## WS-F: Prototype pollution gadget correlation (Medium)

### F.0 Current state

The `prototype_chain_execution_hijack` pattern exists in `dynamic.rs`. It currently fires on:

- `__proto__` assignment with function interception.

Static analysis has `js.prototype_pollution_gadget` detection in `static_analysis.rs` (byte-level pattern matching for `__proto__`, `constructor.prototype`, `Object.setPrototypeOf`).

**Delta**: Extend mutation capture to cover more prototype-mutating calls, add a compact gadget catalogue for correlation, and refine the pattern to require gadget-relevant sink proximity.

### F.1 Mutation capture

Extend mutation capture with:

- `__proto__`, `prototype`, `constructor` write attempts
- prototype-mutating call capture (`Object.setPrototypeOf`, `Reflect.setPrototypeOf`, `Object.defineProperty`)
- eval-sourced prototype mutation markers.

### F.2 Gadget model

Introduce compact gadget catalogue as a constant array in `dynamic.rs` (internal table, no external dependency):

```rust
struct GadgetEntry {
    family: &'static str,      // "dom_sink", "execution", "server"
    sink_call: &'static str,   // e.g. "innerHTML", "eval", "child_process.exec"
    description: &'static str,
}

const GADGET_CATALOGUE: &[GadgetEntry] = &[
    // DOM sink gadgets (~5-8 entries)
    GadgetEntry { family: "dom_sink", sink_call: "innerHTML", description: "DOM XSS via polluted property" },
    // Execution gadgets (~3-5 entries)
    GadgetEntry { family: "execution", sink_call: "eval", description: "Code execution via polluted dispatch" },
    // Server-like gadgets (~3-5 entries, observable in Node profile)
    GadgetEntry { family: "server", sink_call: "child_process.exec", description: "RCE via polluted spawn options" },
    // ... ~15-20 total entries
];
```

Target size: 15-20 entries covering the most common gadget families from published research (GHunter, FollowMyFlow).

### F.3 Correlation logic

Pattern fires at higher confidence only when:

1. mutation observed, and
2. gadget-relevant sink observed within bounded call distance.

### F.4 Pattern updates

Refine `prototype_chain_execution_hijack`:

- include gadget hit metadata:
  - `gadget_family_hits`
  - `mutation_to_sink_distance`
  - `eval_source_markers`

### F.5 Tests

- positive gadget chains (client-side and Node-like).
- mutation-only control (must be lower confidence).
- sink-only control (must not trigger).

---

## WS-G: Node/Bun lifecycle script profile support (Medium)

### G.0 Current state

The `RuntimeKind` enum has three variants: `PdfReader`, `Browser`, `Node`. The existing Node profile uses `RuntimeKind::Node` with vendor/version/mode fields on `RuntimeProfile`.

The `runtime_dependency_loader_abuse` pattern fires on `require()` calls with `child_process`, `fs`, `http`, `https` modules combined with `exec`/`spawn`/`writeFile`.

Stubs for `require` exist in `register_require_stub()` covering `fs`, `path`, `os`, `child_process`, `http`, `https`.

There is no `Bun` runtime kind. There are no lifecycle phase hooks (preinstall/postinstall). There is no heuristic for detecting lifecycle script context.

**Delta**: Add a `Bun` variant to `RuntimeKind`, add lifecycle phase hooks as internal micro-phases (similar to WS-A's SW micro-phases), add heuristics for detecting lifecycle context, and use lifecycle confirmation to uplift confidence on existing patterns.

### G.1 Profile extension

Add `Bun` as a new `RuntimeKind` variant:

```rust
enum RuntimeKind {
    PdfReader,
    Browser,
    Node,
    Bun,   // new
}
```

Profile string format remains `<kind>:<vendor>:<version>:<mode>` e.g.:

- `node:npm:20:compat`
- `bun:bun:1.1:compat`

The existing `RuntimeProfile` struct is unchanged; `kind` field uses the new enum variant. `register_profiled_stubs()` branches on `RuntimeKind::Bun` to register Bun-specific globals (e.g. `Bun.spawn`, `Bun.file`, `Bun.write`).

### G.2 Lifecycle emulation

Add synthetic lifecycle hooks as internal micro-phases (same mechanism as WS-A):

- `npm.preinstall`
- `npm.install`
- `npm.postinstall`
- `bun.install`

Trigger model with concrete heuristics:

1. **Explicit option flag**: `DynamicOptions.lifecycle_context: Option<LifecycleContext>` (new field) allows callers to specify lifecycle phase directly.
2. **Script content heuristics** (when no explicit flag): detect lifecycle context when script contains:
   - `process.env.npm_lifecycle_event` access,
   - `process.env.npm_package_name` access,
   - shebang lines (`#!/usr/bin/env node`, `#!/usr/bin/env bun`),
   - `child_process.exec`/`spawn` combined with filesystem writes in the first 50 calls.

When lifecycle context is detected or specified, lifecycle micro-phases execute after standard phases, following the same accumulative `SandboxLog` model as WS-A.

### G.3 Telemetry

- `js.runtime.lifecycle.phase`
- `js.runtime.lifecycle.hook_calls`
- `js.runtime.lifecycle.background_attempts`

### G.4 Divergence impact

Adding `RuntimeKind::Bun` introduces a new profile that will be included in multi-profile runs by the `JavaScriptSandboxDetector`. The `ProfileDivergenceSummary` must include Bun runs in its profile count and ratio calculations. Since the summary already iterates over all `ProfileRun` results generically, no structural change is needed; the new profile is automatically included. Test coverage must verify that divergence labels remain correct with 4+ profiles.

### G.5 Pattern leverage

Improve confidence for:

- `runtime_dependency_loader_abuse`
- `lotl_api_chain_execution`

when lifecycle context is confirmed.

### G.6 Tests

- lifecycle-specific unit tests in `crates/js-analysis/tests/dynamic_signals.rs`.
- detector integration for lifecycle metadata propagation.
- divergence summary tests with Bun profile included.

---

## 5. PR-sized Milestones

1. **PR-1a (WS-A stubs + telemetry)**
   Service Worker runtime surface stubs, telemetry counters, unit tests. No orchestration changes.

2. **PR-1b (WS-A orchestration + pattern)**
   SW lifecycle micro-phase execution model, `service_worker_persistence_abuse` refinement, deterministic ordering tests.

3. **PR-1c (WS-B)**
   WebSocket/WebRTC session telemetry, `covert_realtime_channel_abuse` refinement, tests.

4. **PR-2a (WS-C source/sink capture)**
   `TaintEvent` and `TaintEdge` structs, source and sink event recording in stubs, unit tests for event capture.

5. **PR-2b (WS-C correlation + integration)**
   Edge correlation logic, `MAX_TAINT_CALL_DISTANCE`/`MAX_TAINT_EDGES` caps, pattern confidence integration, determinism tests.

6. **PR-3 (WS-D)**
   Shared `ExfilUrlFeatures` extractor + scoring refactor + regression replay pack.

7. **PR-4 (WS-E)**
   `wasm_features.rs` module + bounded parser + runtime correlation + pattern refinements.

8. **PR-5 (WS-F)**
   Prototype mutation/gadget correlation + `GADGET_CATALOGUE` + confidence calibration updates.

9. **PR-6 (WS-G)**
   `RuntimeKind::Bun` + lifecycle hooks + profile context propagation + divergence tests.

Execution order (strict):

1. PR-1a
2. PR-1b
3. PR-1c
4. PR-2a
5. PR-2b
6. PR-3
7. PR-4
8. PR-5
9. PR-6

Parallelisation note:

- WS-E and WS-F may run in parallel after PR-3 if shared telemetry contracts remain unchanged.

## 6. Validation Plan

### Baseline capture (before PR-1a)

Run corpus sweep and record starting metrics:

- `cargo test -p js-analysis --features js-sandbox --test dynamic_signals` pass count.
- `cargo test -p sis-pdf-detectors --features js-sandbox --test js_sandbox_integration` pass count.
- Random corpus sweep (`n>=100`):
  - unresolved executed/no-pattern count,
  - false-positive count against benign controls,
  - timeout and telemetry saturation rates.

Store baseline in `plans/20260211-next-001-baseline.json` for comparison.

### Per PR

- `cargo test -p js-analysis --features js-sandbox --test dynamic_signals`
- `cargo test -p sis-pdf-detectors --features js-sandbox --test js_sandbox_integration`
- No regressions in existing tests.

### At PR-3 and PR-6

- random corpus sweep (`n>=100`) with unresolved-bucket tracking.
- compare against baseline:
  - unresolved executed/no-pattern count (must decrease or remain stable),
  - false-positive drift against benign controls (must not increase),
  - timeout and telemetry saturation rates (must not increase).

## 7. Acceptance Criteria

- All new patterns have:
  - positive test,
  - benign control,
  - degraded-chain confidence test,
  - detector integration test.
- No regressions in existing test suites.
- New metadata keys are additive and documented.
- Evidence quality remains non-duplicative and object-linked where available.
- Corpus unresolved bucket count decreases or remains stable relative to recorded baseline with improved precision.
- `ProfileDivergenceSummary` produces valid labels with new phases and profiles.

## 8. Risk Register

- **Risk**: FP increase from broader telemetry surfaces.
  **Mitigation**: multi-signal thresholds + confidence demotion on partial chains.

- **Risk**: Runtime overhead from new instrumentation.
  **Mitigation**: bounded collectors, shared feature extractors, strict caps.

- **Risk**: Profile divergence noise from new phases and profiles.
  **Mitigation**: profile-aware confidence adjustment already in detector bridge; extend calibration tables. Verify divergence ratios remain meaningful with new Bun profile and SW micro-phases.

- **Risk**: WASM parser abuse by malformed inputs.
  **Mitigation**: strict bounded parser (1 MiB max, 32 sections max), checked slicing, fail-safe early exits.

- **Risk**: Taint edge explosion on pathological inputs.
  **Mitigation**: `MAX_TAINT_EDGES` cap (64), `MAX_TAINT_CALL_DISTANCE` window (512 calls).

- **Risk**: Exfil scoring refactor (WS-D) regresses existing pattern confidence.
  **Mitigation**: existing test fixtures must produce identical or higher confidence; any drop is a blocking test failure.

## 9. Deliverables Checklist

- [x] Baseline metrics captured
- [x] WS-A implemented
- [x] WS-B implemented
- [x] WS-C implemented
- [x] WS-D implemented
- [x] WS-E implemented
- [x] WS-F implemented
- [x] WS-G implemented
- [x] Findings docs updated
- [x] Query guide examples updated
- [x] Sweep metrics updated
