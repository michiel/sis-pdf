# egui WASM feasibility: browser-native PDF analysis

Date: 2026-02-15
Status: Implemented (PR-W1 through PR-W3)
Owner: new crate `sis-pdf-gui` + feature-flag changes across workspace

## 1) Objective

Establish feasibility of compiling the sis analysis pipeline to WebAssembly and running it in a browser with an egui-based minimal UI, with no backend server. The user drops a PDF, analysis runs entirely client-side, and findings are displayed in the browser.

This plan covers feasibility validation and a minimal UI only. ML scoring is out of scope.

## 2) Feasibility assessment

### 2.1 Dependency audit

Every dependency in the analysis path has been audited for `wasm32-unknown-unknown` compatibility.

**Parser crate (`sis-pdf-pdf`) -- CLEAN:**

All dependencies are pure Rust with no platform constraints:
- anyhow, base64, flate2, memchr, serde, tracing, thiserror, weezl
- No `std::fs`, no `std::thread`, no `std::net` usage in source.

**Detector crate (`sis-pdf-detectors`) -- CLEAN:**

All dependencies are pure Rust:
- anyhow, hex, sha2, base64, flate2, roxmltree, lzma-rust2, tracing
- Internal crate deps: sis-pdf-core, sis-pdf-pdf, js-analysis, font-analysis, image-analysis
- No `std::fs`, no `std::thread` usage in source.

**JS analysis crate (`js-analysis`) -- COMPATIBLE:**

- Boa engine (parser, AST, interner, engine, GC) explicitly supports WASM. Boa ships an official WASM playground.
- `std::fs` usage is only in `bin/js-corpus-harness.rs` and `corpus_regression.rs` (test/tool code, not library).
- `std::thread::spawn` is used in `dynamic.rs:4301` for sandbox timeout enforcement. This needs a feature gate (see Section 3.2).

**Font analysis crate (`font-analysis`) -- COMPATIBLE:**

- skrifa, ttf-parser, allsorts are all pure Rust with confirmed WASM support.
- All three are behind the `dynamic` feature flag already.
- `std::fs` usage is only in `signatures.rs:627` inside a `#[cfg(test)]` block.
- `std::thread::spawn` is used in `lib.rs:224` for timeout enforcement. Needs a feature gate (see Section 3.2).

**Image analysis crate (`image-analysis`) -- COMPATIBLE:**

- All decoders (hayro-jbig2, hayro-jpeg2000, jpeg-decoder, png, tiff) are pure Rust.
- All behind individual feature flags already.
- No `std::fs`, no `std::thread` usage.

**Core crate (`sis-pdf-core`) -- NEEDS WORK:**

Three categories of incompatibility:

| Issue | Files | Impact |
|---|---|---|
| `std::fs` | cache.rs, config.rs, ml_models.rs, ml_inference.rs, filter_allowlist.rs, explainability.rs, temporal.rs | Cannot read files from WASM |
| `rayon` | runner.rs:167-168 | current build target/runtime does not enable wasm threads; keep sequential path for browser MVP |
| `std::time::Instant` | Various (if using `Instant::now()`) | behaviour differs by target/runtime; standardise timing via `web_time` or feature-gate profiling paths |

**ML graph crate (`sis-pdf-ml-graph`) -- EXCLUDED:**

Out of scope for this plan. Already optional behind `ml-graph` feature flag on `sis-pdf-core`.

### 2.2 Summary

| Crate | WASM ready | Changes needed |
|---|---|---|
| `sis-pdf-pdf` | Yes | None |
| `sis-pdf-detectors` | Yes | None (propagates feature flags from deps) |
| `js-analysis` | Yes | Feature-gate `std::thread` timeout in dynamic.rs |
| `font-analysis` | Yes | Feature-gate `std::thread` timeout in lib.rs |
| `image-analysis` | Yes | None |
| `sis-pdf-core` | Partial | Feature-gate `std::fs` callers and `rayon` |
| `sis-pdf-ml-graph` | N/A | Excluded via existing feature flag |

The parser and all detectors compile to WASM without changes. The core crate needs feature-gated alternatives for filesystem, threading, and parallelism.

## 3) Required changes to existing crates

### 3.1 `sis-pdf-core`: rayon parallelism gate

`runner.rs:166-168` uses rayon for parallel detector execution. Add a feature flag:

```toml
# crates/sis-pdf-core/Cargo.toml
[features]
parallel = ["rayon"]

[dependencies]
rayon = { version = "1.10", optional = true }
```

In `runner.rs`, branch on the feature:

```rust
let mut findings: Vec<Finding> = if ctx.options.parallel {
    #[cfg(feature = "parallel")]
    {
        // existing rayon pool logic
    }
    #[cfg(not(feature = "parallel"))]
    {
        // sequential fallback: detectors.iter().filter(...).filter_map(...)
    }
} else {
    // existing sequential path
};
```

The sequential path already exists in `runner.rs` for the `!ctx.options.parallel` branch. The feature gate reuses it when parallel execution is unavailable for the browser target.

### 3.2 `js-analysis` and `font-analysis`: thread timeout gate

Both crates use `std::thread::spawn` solely for timeout enforcement around dynamic analysis:
- `js-analysis/src/dynamic.rs:4301`
- `font-analysis/src/lib.rs:224`

These are already behind feature flags (`js-sandbox` and `dynamic` respectively). For WASM, disable these features. Static analysis (JS AST parsing, font structure validation, signature matching) works without them.

No code changes needed if the WASM build simply omits `js-sandbox` and `font-dynamic` features. If dynamic analysis is wanted on WASM later, the timeout mechanism can be replaced with `wasm-bindgen-futures` + `setTimeout`, but that is out of scope.

### 3.3 `sis-pdf-core`: filesystem usage gate

The `std::fs` callers in core are all in modules that are irrelevant to a WASM analysis session:

| Module | Purpose | WASM relevance |
|---|---|---|
| `cache.rs` | Disk-based scan result cache | None -- no disk in browser |
| `config.rs` | TOML config file loading | None -- config comes from UI |
| `ml_models.rs` | ML model file loading | None -- ML excluded |
| `ml_inference.rs` | ML inference config loading | None -- ML excluded |
| `filter_allowlist.rs` | Load filter allowlist from file | None -- embed or omit |
| `explainability.rs` | Persist/load explanation reports | None -- render in UI |
| `temporal.rs` | Read PDF bytes from path | None -- bytes come from JS |

Strategy: guard these modules behind a `filesystem` feature (default-on for native, off for WASM).

```toml
# crates/sis-pdf-core/Cargo.toml
[features]
default = ["parallel", "filesystem"]
parallel = ["rayon"]
filesystem = []
```

Each `std::fs` call site gets `#[cfg(feature = "filesystem")]`. Functions that load from paths get companion functions that accept `&[u8]` or `&str` (most already exist -- `ScanContext::new()` takes `&[u8]`).

The scan pipeline itself (`ScanContext::new()`, `run_detectors()`, `correlate_findings()`) does not use `std::fs` at all. It operates on `&[u8]` throughout.

### 3.4 `std::time::Instant` on WASM

`Instant::now()` behaviour varies across toolchains/runtimes in browser targets. Two options:
1. Use the `web-time` crate (drop-in replacement, uses `performance.now()` on WASM).
2. Feature-gate profiling/timing code.

Recommendation: add `web-time` as a dependency on WASM targets via `[target.'cfg(target_arch = "wasm32")'.dependencies]`. Alias it to `Instant` with a conditional import, and keep profiling/timing code behind a feature so runtime failures fail closed.

### 3.5 Browser security profile (mandatory limits)

Define and enforce a non-configurable WASM analysis profile for MVP:

1. `max_objects` hard cap (e.g. 250_000).
2. `max_decode_bytes` and `max_total_decoded_bytes` hard caps.
3. `max_recursion_depth` hard cap.
4. Per-detector work-unit caps (object count limits, byte limits) where supported. Wall-clock timeouts depend on `web-time` (Section 3.4) and are best-effort on WASM.
5. File-size intake cap at UI boundary (e.g. 50 MB default).
6. On limit hit: emit explicit guardrail finding/metadata and return partial-but-valid results (no panic, no hang).

These caps are runtime values set via `ScanOptions` by the GUI crate's analysis entry point, not compile-time constants in `sis-pdf-core`. This keeps native builds unaffected. The GUI crate owns the hardened profile; the CLI crate continues to use its existing defaults. Implementation is in PR-W2 (Section 6).

## 4) New crate: `sis-pdf-gui`

### 4.1 Crate structure

```
crates/sis-pdf-gui/
  Cargo.toml
  src/
    lib.rs          -- wasm-bindgen entry point + file drop handler
    app.rs          -- eframe::App implementation
    panels/
      drop_zone.rs  -- file drop UI
      summary.rs    -- finding summary panel
      findings.rs   -- findings table with sort/filter
      detail.rs     -- single finding detail view
      chains.rs     -- chain visualisation (text-based)
```

### 4.2 Dependencies

```toml
[package]
name = "sis-pdf-gui"
version.workspace = true
edition = "2021"

[dependencies]
eframe = { version = "0.31", default-features = false, features = ["wgpu", "web_screen_reader"] }
egui = "0.31"
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["File", "FileReader", "DragEvent", "DataTransfer"] }
js-sys = "0.3"
serde = { workspace = true }
serde_json = { workspace = true }
tracing = { workspace = true }

# Analysis pipeline (no filesystem, no parallelism, no ML)
sis-pdf-core = { path = "../sis-pdf-core", default-features = false }
sis-pdf-pdf = { path = "../sis-pdf-pdf" }
sis-pdf-detectors = { path = "../sis-pdf-detectors", default-features = false, features = ["js-ast"] }

[lib]
crate-type = ["cdylib"]
```

Feature selection rationale:
- `sis-pdf-core` with `default-features = false` -- excludes `parallel` and `filesystem`.
- `sis-pdf-detectors` with `features = ["js-ast"]` -- includes JS static analysis (Boa parser/AST), excludes `js-sandbox` (thread-dependent) and `font-dynamic` (thread-dependent).
- Static font analysis (signature matching, structure validation) works without the `dynamic` feature.
- All image decoders are included (they have no platform constraints).

### 4.3 WASM entry point

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    // Set up panic hook for readable WASM errors
    console_error_panic_hook::set_once();
    // Start eframe
    let web_options = eframe::WebOptions::default();
    wasm_bindgen_futures::spawn_local(async {
        eframe::WebRunner::new()
            .start("sis_canvas", web_options, Box::new(|cc| Ok(Box::new(app::SisApp::new(cc)))))
            .await
            .expect("failed to start eframe");
    });
    Ok(())
}
```

### 4.4 Analysis flow

1. User drops a PDF file onto the browser canvas.
2. JavaScript `FileReader` reads the file bytes via `web-sys`.
3. Bytes are passed to the Rust analysis pipeline:
   - `sis_pdf_pdf::parse_pdf(&bytes)` -- build object graph.
   - `ScanContext::new(&bytes, graph, options)` -- create analysis context.
   - run detector orchestration through the existing core/query-compatible path (no duplicated pipeline logic in GUI crate).
   - apply correlation/composite enrichment and stable IDs exactly as native flow does.
4. Results are stored in the `SisApp` state.
5. egui renders the findings.

Analysis runs synchronously on the main thread for the minimal UI. If this causes noticeable UI freezing (>200ms), a follow-up can move analysis to a Web Worker via `wasm-bindgen-rayon` or message passing. Typical triage completes in <50ms, so this is unlikely to be an issue.

Implementation note: all heavy processing must be chunkable or cancellable in follow-up work; the MVP should at minimum surface progress and guardrail outcomes.

### 4.5 Minimal UI panels

**Drop zone (initial state):**
- Centred drop target with instructions.
- File name and size displayed after drop.
- Analysis progress indicator (for deep analysis on large files).

**Summary panel (after analysis):**
- File metadata: pages, version, encrypted, file size.
- Finding count by severity (critical/high/medium/low/info).
- Chain count.
- Attack surface coverage summary.

**Findings table:**
- Columns: severity, confidence, kind, attack surface, description.
- Sort by column header click.
- Filter by severity (toggle buttons).
- Click row to open detail view.

**Finding detail panel:**
- Full finding metadata.
- Evidence spans with object references.
- Reader impact annotations (Acrobat/PDFium/Preview).
- Related chain context if the finding participates in a chain.

**Chain panel:**
- Text-based chain display: trigger -> action -> payload.
- Severity and confidence for each chain.
- Linked finding references.

No stream decoding, no interactive query REPL, no explain rendering in the minimal UI. These are follow-up features.

## 5) Build and deployment

### 5.1 Build toolchain

Prerequisites:

```bash
# Install wasm target (one-time)
rustup target add wasm32-unknown-unknown

# Install trunk for WASM bundling (one-time)
cargo install --locked trunk
```

Development:

```bash
# Dev server with hot reload (http://127.0.0.1:8080)
cd crates/sis-pdf-gui
trunk serve
```

Production build:

```bash
cd crates/sis-pdf-gui
trunk build --release
```

The `--release` flag enables Rust optimisations and runs `wasm-opt -O2` on the output
(configured via `data-wasm-opt="2"` in `index.html`).

### 5.2 `index.html`

The `index.html` includes:
- `<link data-trunk rel="rust" data-wasm-opt="2" />` -- tells trunk to compile the Rust
  crate to WASM and apply `wasm-opt` level 2 optimisation.
- A `<canvas id="sis_canvas">` element used by eframe as the rendering surface.
- A loading spinner that is removed once the WASM module initialises.

The WASM entry point is `lib.rs::start_wasm()`, annotated with
`#[wasm_bindgen(start)]` so it runs automatically when the module loads.

### 5.3 Output

Trunk produces a `dist/` directory containing:
- `index.html`
- `sis-pdf-gui_bg.wasm` (the compiled WASM module)
- `sis-pdf-gui.js` (generated JS glue)

This can be served from any static file host (GitHub Pages, S3, Netlify) with no backend.

### 5.4 CI/CD

The `.github/workflows/release-web.yml` workflow:
1. Triggers on `v*` tags (same as the CLI release workflow).
2. Installs Rust stable with `wasm32-unknown-unknown` target.
3. Installs trunk via `cargo install --locked trunk`.
4. Runs `trunk build --release` in `crates/sis-pdf-gui`.
5. Zips the `dist/` directory into `sis-web-<version>.zip`.
6. Attaches the zip to the GitHub Release (created by either this workflow or `release-cli.yml`,
   whichever runs first -- `softprops/action-gh-release@v2` handles both cases).

The zip archive is self-contained: unzip and serve from any static host.

### 5.4 WASM size budget

Expected uncompressed WASM binary size estimate:

| Component | Estimated size |
|---|---|
| sis-pdf-pdf (parser) | ~200 KB |
| sis-pdf-core (analysis engine) | ~400 KB |
| sis-pdf-detectors (40+ detectors) | ~600 KB |
| js-analysis (Boa AST, no sandbox) | ~1.5 MB |
| font-analysis (static only) | ~300 KB |
| image-analysis (all decoders) | ~400 KB |
| egui + eframe (WASM renderer) | ~1.0 MB |
| Total uncompressed | ~4.4 MB |
| Brotli compressed (typical 4x) | ~1.1 MB |

This is within acceptable range for a browser application. The Boa engine is the largest contributor. If size becomes a concern, `js-ast` can be made optional in the GUI build.

## 6) Implementation plan

### PR-W1: Feature-gate `sis-pdf-core` for WASM compatibility

Changes:
1. Make `rayon` optional behind `parallel` feature in `sis-pdf-core/Cargo.toml`.
2. Add `#[cfg(feature = "parallel")]` / `#[cfg(not(feature = "parallel"))]` branches in `runner.rs`.
3. Add `filesystem` feature flag; guard `std::fs` call sites in cache.rs, config.rs, ml_models.rs, ml_inference.rs, filter_allowlist.rs, explainability.rs, temporal.rs.
4. Add `web-time` dependency for `wasm32` target; conditional import for `Instant`.
5. Ensure `default = ["parallel", "filesystem"]` so native builds are unchanged.

Tests:
1. `cargo test` passes with default features (no regression).
2. `cargo check -p sis-pdf-core --no-default-features` compiles.
3. `cargo check -p sis-pdf-core --no-default-features --target wasm32-unknown-unknown` compiles.

Validation gate: the core crate compiles for `wasm32-unknown-unknown` with `--no-default-features`.

### PR-W2: Verify full pipeline compiles to WASM

Changes:
1. Add `sis-pdf-gui` crate to workspace with minimal `lib.rs` (wasm-bindgen entry point, no UI yet).
2. Wire dependencies: `sis-pdf-core` (no-default-features), `sis-pdf-pdf`, `sis-pdf-detectors` (js-ast only).
3. Add an exported analysis entry point using wasm-bindgen-compatible ABI:
   - internal Rust API may use `&[u8]`,
   - exported boundary uses `Vec<u8>` or `js_sys::Uint8Array`.
4. Ensure the exported function returns structured JSON with explicit error envelope.
5. Implement browser security profile (Section 3.5) in the GUI analysis entry point:
   - construct `ScanOptions` with hardened runtime caps (`max_objects`, `max_decode_bytes`, `max_total_decoded_bytes`, `max_recursion_depth`) as constants in the GUI crate, not configurable by the caller.
   - apply file-size intake cap before passing bytes to the pipeline; reject with structured error if exceeded.
   - on limit hit during analysis, return partial-but-valid results with guardrail finding/metadata indicating which cap was reached.
6. Add integration tests calling the native-facing API with fixture PDFs and asserting findings are produced.

Tests:
1. `cargo check -p sis-pdf-gui --target wasm32-unknown-unknown` compiles.
2. Native integration tests pass: analysis API on fixtures returns valid JSON with expected finding kinds.
3. WASM integration test (via `wasm-pack test --headless --chrome`): exported API returns findings on small fixtures.
4. Parity matrix test: selected fixtures produce equivalent core finding sets (kind/severity/confidence) between native and WASM.
5. File exceeding intake cap is rejected with structured error, not a panic.
6. Fixture exceeding an object or decode cap returns partial results with guardrail metadata.

Validation gate: the full analysis pipeline executes in a browser WASM context and produces correct findings.

### PR-W3: Minimal egui UI

Changes:
1. Add eframe app structure with drop zone, summary, findings table, detail panel, chain panel.
2. Wire file drop via `web-sys` FileReader to `analyze()`.
3. Add `trunk` build configuration (`Trunk.toml`, `index.html`).
4. Style with egui defaults (no custom theming for now).

Tests:
1. `trunk build --release` produces a working `dist/` directory.
2. Manual browser test: drop a PDF, verify findings render.
3. Findings table sort and severity filter work.
4. Chain panel displays chain structure for a fixture with known chains.

Validation gate: a user can open the page in a browser, drop a PDF, and see analysis results with no backend.

## 7) What is excluded from the minimal UI

1. ML scoring (excluded at dependency level).
2. JS sandbox / dynamic analysis (thread-dependent, excluded via feature flags).
3. Dynamic font analysis (thread-dependent, excluded via feature flags).
4. Stream decoding / hex dump viewer.
5. Interactive query REPL.
6. Explain rendering.
7. Batch analysis / multi-file comparison.
8. Report generation / export.
9. Custom theming or branding.

All of these are follow-up features that can be added incrementally once feasibility is confirmed.

## 8) Risks and mitigations

1. **Risk:** Boa AST parsing is slow on WASM for large JS payloads.
   Mitigation: the `js-ast` feature runs static pattern matching and AST analysis, not full execution. It is bounded by the existing JS size limits in `js-analysis`. If slow, add a WASM-specific timeout via `setTimeout` or cap JS analysis size more aggressively.

2. **Risk:** WASM binary too large for acceptable load times.
   Mitigation: Brotli compression typically achieves 4x reduction. If still too large, make `js-ast` and image decoders optional in the GUI build. Core analysis (parser + structure + action detectors) alone would be ~1 MB compressed.

3. **Risk:** Analysis of large PDFs (>10 MB) causes browser tab OOM or UI freeze.
   Mitigation: add a file size cap in the drop handler (e.g. 50 MB). For the minimal UI, synchronous analysis is acceptable because typical triage is <50ms. If large-file support is needed later, offload to a Web Worker.

4. **Risk:** `lopdf` path causes WASM incompatibility or bloat.
   Mitigation: lopdf is pure Rust and has no C dependencies. If it has a hidden WASM incompatibility, it is used only as the secondary parser in `sis-pdf-core/src/diff.rs`. It can be feature-gated out for WASM without losing primary analysis capability. PR-W1 will validate this.

5. **Risk:** Feature-gating `rayon` and `filesystem` breaks native builds.
   Mitigation: both features are default-on. `cargo test` with default features is the first validation gate in PR-W1.

6. **Risk:** Timing/profiling path divergence causes runtime instability on WASM.
   Mitigation: use `web-time` for WASM and gate profiling paths behind feature flags with explicit fallback.

7. **Risk:** Browser-hosted analysis opens denial-of-service vectors (large/deep crafted PDFs).
   Mitigation: enforce WASM security profile hard caps and emit guardrail findings/metadata on early termination.

## 9) Exit criteria

1. `cargo check --target wasm32-unknown-unknown` succeeds for `sis-pdf-gui` and all transitive dependencies.
2. `wasm-pack test --headless --chrome` passes an integration test that analyses a fixture PDF in a browser context.
3. `trunk build --release` produces a deployable `dist/` with WASM module under 2 MB compressed.
4. A user can open the page, drop a PDF, and see: file metadata, finding counts by severity, a sortable/filterable findings table, finding detail on click, and chain summaries.
5. Native `cargo test` passes across the entire workspace with no regressions from feature-flag changes.
6. A documented parity matrix demonstrates equivalent findings (kind/severity/confidence) for the selected fixture set between native and WASM modes.
7. Guardrail outcomes (limit hits/time budgets) are surfaced in results as structured metadata/findings.
