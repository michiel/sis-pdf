use anyhow::Result;

use font_analysis::model::{Confidence as FontConfidence, Severity as FontSeverity};
use font_analysis::{analyse_font, FontAnalysisConfig};
use sis_pdf_core::detect::{Cost, Detector, Needs};
use sis_pdf_core::model::{AttackSurface, Confidence, Finding, Impact, Severity};
use sis_pdf_core::scan::span_to_evidence;
use sis_pdf_core::security_log::{SecurityDomain, SecurityEvent};
use sis_pdf_pdf::content::parse_content_ops;
use sis_pdf_pdf::decode::stream_filters;
use sis_pdf_pdf::object::{PdfAtom, PdfDict, PdfStream};
use tracing::Level;

use crate::entry_dict;

pub struct FontExploitDetector;

impl Detector for FontExploitDetector {
    fn id(&self) -> &'static str {
        "font_exploit"
    }

    fn surface(&self) -> AttackSurface {
        AttackSurface::StreamsAndFilters
    }

    fn needs(&self) -> Needs {
        Needs::OBJECT_GRAPH
    }

    fn cost(&self) -> Cost {
        Cost::Moderate
    }

    fn run(&self, ctx: &sis_pdf_core::scan::ScanContext) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        let cfg = FontAnalysisConfig {
            enabled: ctx.options.font_analysis.enabled,
            dynamic_enabled: ctx.options.font_analysis.dynamic_enabled,
            dynamic_timeout_ms: ctx.options.font_analysis.dynamic_timeout_ms,
            max_fonts: ctx.options.font_analysis.max_fonts,
            signature_matching_enabled: ctx.options.font_analysis.signature_matching_enabled,
            signature_directory: ctx.options.font_analysis.signature_directory.clone(),
            ..Default::default()
        };
        if !cfg.enabled {
            return Ok(findings);
        }
        let mut seen = 0usize;
        for entry in &ctx.graph.objects {
            let Some(dict) = entry_dict(entry) else {
                continue;
            };
            findings.extend(font_structure_consistency_findings(
                entry.obj,
                entry.gen,
                dict,
                entry.full_span,
            ));
            findings.extend(type3_charproc_findings(ctx, entry.obj, entry.gen, dict));
            findings.extend(tounicode_cmap_findings(ctx, entry.obj, entry.gen, dict));
            for key in [b"/FontFile".as_slice(), b"/FontFile2".as_slice(), b"/FontFile3".as_slice()]
            {
                if let Some((_, obj)) = dict.get_first(key) {
                    if let Some(stream) = resolve_stream(ctx, obj) {
                        if seen >= ctx.options.font_analysis.max_fonts {
                            SecurityEvent {
                                level: Level::WARN,
                                domain: SecurityDomain::Detection,
                                severity: sis_pdf_core::model::Severity::Low,
                                kind: "font_analysis_limit",
                                policy: None,
                                object_id: None,
                                object_type: None,
                                vector: None,
                                technique: None,
                                confidence: None,
                                fatal: false,
                                message: "Font analysis limit reached; skipping remaining fonts",
                            }
                            .emit();
                            return Ok(findings);
                        }
                        seen += 1;
                        let span = stream.data_span;
                        let raw_len = span.len() as usize;
                        let filters = stream_filters(&stream.dict);
                        let mut base_meta = std::collections::HashMap::new();
                        base_meta.insert("font.stream_len".into(), raw_len.to_string());
                        if !filters.is_empty() {
                            base_meta.insert("font.stream_filters".into(), filters.join(","));
                        }
                        let object_label = format!("{} {} obj", entry.obj, entry.gen);
                        if let Some(font_name) = font_name_from_dict(dict) {
                            base_meta.insert("font.name".into(), font_name.clone());
                        }
                        base_meta.insert("font.object_id".into(), object_label.clone());
                        base_meta.insert(
                            "font.object_provenance".into(),
                            entry.provenance.label(),
                        );
                        let revisions = ctx.graph.all_objects_by_id(entry.obj, entry.gen).len();
                        if revisions > 1 {
                            base_meta.insert(
                                "font.object_shadowed_revisions".into(),
                                revisions.to_string(),
                            );
                        }
                        if ctx
                            .graph
                            .deviations
                            .iter()
                            .any(|deviation| deviation.kind.contains("xref"))
                        {
                            base_meta.insert("font.xref_conflict_signal".into(), "true".into());
                        }

                        let decoded = match ctx.decoded.get_or_decode(ctx.bytes, &stream) {
                            Ok(decoded) => decoded,
                            Err(err) => {
                                let mut meta = base_meta.clone();
                                meta.insert("font.decode_error".into(), err.to_string());
                                findings.push(Finding {
                                    id: String::new(),
                                    surface: self.surface(),
                                    kind: "font.invalid_structure".into(),
                                    severity: Severity::Medium,
                                    confidence: Confidence::Probable,
                                    impact: None,
                                    title: "Font stream decode failed".into(),
                                    description: "Embedded font stream could not be decoded."
                                        .into(),
                                    objects: build_font_objects(&object_label, dict),
                                    evidence: vec![span_to_evidence(
                                        stream.data_span,
                                        "Font stream",
                                    )],
                                    remediation: Some(
                                        "Inspect embedded font streams and filters.".into(),
                                    ),
                                    meta,
                                    yara: None,
                                    positions: Vec::new(),
                                    ..Finding::default()
                                });
                                continue;
                            }
                        };

                        if revisions > 1 {
                            let mut provenance_meta = base_meta.clone();
                            provenance_meta.insert(
                                "font.fontfile_key".into(),
                                String::from_utf8_lossy(key).to_string(),
                            );
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font.provenance_incremental_override".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Strong,
                                impact: Some(Impact::Medium),
                                title: "Font object overridden across revisions".into(),
                                description:
                                    "The font object identifier appears in multiple revisions, indicating override behaviour."
                                        .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font object revision override")],
                                remediation: Some(
                                    "Inspect historical revisions of embedded fonts for hidden payload changes.".into(),
                                ),
                                meta: provenance_meta.clone(),
                                yara: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });

                            if ctx
                                .graph
                                .deviations
                                .iter()
                                .any(|deviation| deviation.kind.contains("xref"))
                            {
                                findings.push(Finding {
                                    id: String::new(),
                                    surface: AttackSurface::FileStructure,
                                    kind: "resource.provenance_xref_conflict".into(),
                                    severity: Severity::High,
                                    confidence: Confidence::Probable,
                                    impact: Some(Impact::High),
                                    title: "Resource provenance intersects xref conflict".into(),
                                    description:
                                        "Font resource revision overrides co-occur with xref conflict signals."
                                            .into(),
                                    objects: build_font_objects(&object_label, dict),
                                    evidence: vec![span_to_evidence(stream.data_span, "Resource provenance xref conflict")],
                                    remediation: Some(
                                        "Validate xref consistency and inspect font object history across revisions.".into(),
                                    ),
                                    meta: provenance_meta,
                                    yara: None,
                                    positions: Vec::new(),
                                    ..Finding::default()
                                });
                            }
                        }

                        if raw_len > 2 * 1024 * 1024 {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_payload_present".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Probable,
                                impact: None,
                                title: "Large embedded font payload".into(),
                                description: "Embedded font stream size exceeds expected bounds."
                                    .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Inspect embedded font tables for anomalies.".into(),
                                ),
                                meta,
                                yara: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                        if looks_like_cff(&decoded.data) {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_table_anomaly".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Heuristic,
                                impact: None,
                                title: "Suspicious font table signature".into(),
                                description:
                                    "Font stream contains CFF/OTF markers that warrant inspection."
                                        .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate font table structure and limits.".into(),
                                ),
                                meta,
                                yara: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }

                        let analysis = analyse_font(&decoded.data, &cfg);
                        for finding in analysis.findings {
                            let mut meta = base_meta.clone();
                            meta.extend(finding.meta);
                            let impact = match finding.kind.as_str() {
                                "font.gvar_glyph_count_mismatch" => Some(Impact::High),
                                "font.gvar_offsets_disorder" => Some(Impact::Medium),
                                "font.anomalous_variation_table" => Some(Impact::Medium),
                                _ => None,
                            };
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: finding.kind,
                                severity: map_severity(finding.severity),
                                confidence: map_confidence(finding.confidence),
                                impact,
                                title: finding.title,
                                description: finding.description,
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate embedded font tables and render paths.".into(),
                                ),
                                meta,
                                yara: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                    }
                }
            }
        }
        Ok(findings)
    }
}

fn font_structure_consistency_findings(
    obj: u32,
    gen: u16,
    dict: &PdfDict<'_>,
    span: sis_pdf_pdf::span::Span,
) -> Vec<Finding> {
    let mut findings = Vec::new();
    let object_label = format!("{obj} {gen} obj");

    if let Some((_, subtype_obj)) = dict.get_first(b"/Subtype") {
        if let PdfAtom::Name(subtype) = &subtype_obj.atom {
            let subtype_label = String::from_utf8_lossy(&subtype.decoded).to_string();
            if dict.get_first(b"/FontFile").is_some() && subtype_label != "/Type1" {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert("font.subtype".into(), subtype_label.clone());
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_subtype_mismatch".into(),
                    severity: Severity::High,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::High),
                    title: "Font subtype and embedded stream mismatch".into(),
                    description:
                        "Font dictionary subtype is inconsistent with embedded /FontFile usage."
                            .into(),
                    objects: vec![object_label.clone()],
                    evidence: vec![span_to_evidence(span, "Font subtype mismatch")],
                    remediation: Some(
                        "Validate font descriptor subtype and stream key consistency.".into(),
                    ),
                    meta,
                    yara: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
            if dict.get_first(b"/FontFile3").is_some() && dict.get_first(b"/FontFile").is_some() {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert("font.subtype".into(), subtype_label);
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_subtype_mismatch".into(),
                    severity: Severity::High,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::High),
                    title: "Conflicting embedded font stream keys".into(),
                    description:
                        "Font dictionary declares conflicting embedded stream keys (/FontFile and /FontFile3).".into(),
                    objects: vec![object_label.clone()],
                    evidence: vec![span_to_evidence(span, "Conflicting font stream keys")],
                    remediation: Some(
                        "Inspect descriptor consistency and remove conflicting embedded stream declarations.".into(),
                    ),
                    meta,
                    yara: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
        }
    }

    if let Some((_, encoding)) = dict.get_first(b"/Encoding") {
        if matches!(encoding.atom, PdfAtom::Null) {
            let mut meta = std::collections::HashMap::new();
            meta.insert("font.object_id".into(), object_label.clone());
            findings.push(Finding {
                id: String::new(),
                surface: AttackSurface::StreamsAndFilters,
                kind: "font.structure_encoding_inconsistent".into(),
                severity: Severity::Medium,
                confidence: Confidence::Strong,
                impact: Some(Impact::Medium),
                title: "Inconsistent font encoding declaration".into(),
                description: "Font dictionary contains a null /Encoding declaration.".into(),
                objects: vec![object_label.clone()],
                evidence: vec![span_to_evidence(span, "Font encoding inconsistency")],
                remediation: Some("Validate /Encoding and related cmap declarations.".into()),
                meta,
                yara: None,
                positions: Vec::new(),
                ..Finding::default()
            });
        }
    }

    if let Some((_, cid_to_gid)) = dict.get_first(b"/CIDToGIDMap") {
        if let PdfAtom::Name(name) = &cid_to_gid.atom {
            if name.decoded.as_slice() != b"/Identity" {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert(
                    "font.cid_to_gid_map".into(),
                    String::from_utf8_lossy(&name.decoded).to_string(),
                );
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_mapping_anomalous".into(),
                    severity: Severity::Medium,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::Medium),
                    title: "Anomalous CIDToGIDMap declaration".into(),
                    description:
                        "Font dictionary uses a non-Identity CIDToGIDMap name, which is uncommon and can hide mapping abuse."
                            .into(),
                    objects: vec![object_label],
                    evidence: vec![span_to_evidence(span, "Font mapping anomaly")],
                    remediation: Some(
                        "Inspect character map behaviour and downstream renderer interpretation.".into(),
                    ),
                    meta,
                    yara: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
        }
    }

    findings
}

fn type3_charproc_findings(
    ctx: &sis_pdf_core::scan::ScanContext<'_>,
    obj: u32,
    gen: u16,
    dict: &PdfDict<'_>,
) -> Vec<Finding> {
    if !dict.has_name(b"/Subtype", b"/Type3") {
        return Vec::new();
    }
    let mut findings = Vec::new();
    let object_label = format!("{obj} {gen} obj");
    let Some((_, charprocs_obj)) = dict.get_first(b"/CharProcs") else {
        return findings;
    };
    let Some(charprocs_dict) = resolve_dict_from_obj(ctx, charprocs_obj) else {
        return findings;
    };
    let mut total_ops = 0usize;
    let mut glyph_count = 0usize;
    let mut resource_abuse = 0usize;
    let mut q_depth = 0i32;
    let mut q_depth_peak = 0i32;
    for (_, glyph_obj) in &charprocs_dict.entries {
        let Some(stream) = resolve_stream(ctx, glyph_obj) else {
            continue;
        };
        glyph_count += 1;
        let Ok(decoded) = ctx.decoded.get_or_decode(ctx.bytes, &stream) else {
            continue;
        };
        let ops = parse_content_ops(&decoded.data);
        total_ops += ops.len();
        for op in &ops {
            match op.op.as_str() {
                "q" => {
                    q_depth += 1;
                    if q_depth > q_depth_peak {
                        q_depth_peak = q_depth;
                    }
                }
                "Q" => q_depth -= 1,
                "Do" | "gs" | "Tf" => resource_abuse += 1,
                _ => {}
            }
        }
    }
    if total_ops >= 1200 || glyph_count >= 200 {
        let (severity, confidence, impact) =
            font_followup_profile("font.type3_charproc_complexity_high")
                .expect("profile exists for type3 complexity finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label.clone());
        meta.insert("font.type3.total_ops".into(), total_ops.to_string());
        meta.insert("font.type3.glyph_count".into(), glyph_count.to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.type3_charproc_complexity_high".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "Type 3 charproc complexity is high".into(),
            description: "Type 3 glyph programs contain unusually high operator or glyph counts."
                .into(),
            objects: vec![object_label.clone()],
            evidence: vec![span_to_evidence(dict.span, "Type 3 CharProcs dictionary")],
            remediation: Some(
                "Inspect Type 3 charproc operator density and glyph-level render behaviour.".into(),
            ),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    if resource_abuse > 0 {
        let (severity, confidence, impact) =
            font_followup_profile("font.type3_charproc_resource_abuse")
                .expect("profile exists for type3 resource abuse finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label.clone());
        meta.insert("font.type3.resource_ops".into(), resource_abuse.to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.type3_charproc_resource_abuse".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "Type 3 charproc resource abuse".into(),
            description:
                "Type 3 glyph programs invoke external resources or state operators uncommon for benign glyph drawing."
                    .into(),
            objects: vec![object_label.clone()],
            evidence: vec![span_to_evidence(dict.span, "Type 3 CharProcs dictionary")],
            remediation: Some("Inspect glyph program resource invocations and renderer impacts.".into()),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    if q_depth_peak >= 32 || q_depth > 0 {
        let (severity, confidence, impact) =
            font_followup_profile("font.type3_charproc_recursion_like_pattern")
                .expect("profile exists for type3 recursion-like finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label);
        meta.insert("font.type3.q_depth_peak".into(), q_depth_peak.to_string());
        meta.insert("font.type3.q_depth_final".into(), q_depth.to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.type3_charproc_recursion_like_pattern".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "Type 3 charproc recursion-like pattern".into(),
            description: "Type 3 glyph programs show deep or unbalanced graphics state nesting."
                .into(),
            objects: vec![format!("{obj} {gen} obj")],
            evidence: vec![span_to_evidence(dict.span, "Type 3 graphics state nesting")],
            remediation: Some("Validate graphics state balance in Type 3 charprocs.".into()),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    if total_ops >= 1200
        || glyph_count >= 200
        || resource_abuse > 0
        || q_depth_peak >= 32
        || q_depth > 0
    {
        let (severity, confidence, impact) = font_followup_profile("type3_charproc_suspicious_ops")
            .expect("profile exists for type3 suspicious-ops finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), format!("{obj} {gen} obj"));
        meta.insert("font.type3.total_ops".into(), total_ops.to_string());
        meta.insert("font.type3.glyph_count".into(), glyph_count.to_string());
        meta.insert("font.type3.resource_ops".into(), resource_abuse.to_string());
        meta.insert("font.type3.q_depth_peak".into(), q_depth_peak.to_string());
        meta.insert("font.type3.q_depth_final".into(), q_depth.to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "type3_charproc_suspicious_ops".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "Type 3 charproc suspicious operator profile".into(),
            description:
                "Type 3 glyph programs show operator patterns associated with suspicious execution surfaces."
                    .into(),
            objects: vec![format!("{obj} {gen} obj")],
            evidence: vec![span_to_evidence(dict.span, "Type 3 CharProcs suspicious profile")],
            remediation: Some(
                "Inspect Type 3 charproc operator usage and linked resource access for abuse."
                    .into(),
            ),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    findings
}

fn tounicode_cmap_findings(
    ctx: &sis_pdf_core::scan::ScanContext<'_>,
    obj: u32,
    gen: u16,
    dict: &PdfDict<'_>,
) -> Vec<Finding> {
    let Some((_, to_unicode_obj)) = dict.get_first(b"/ToUnicode") else {
        return Vec::new();
    };
    let Some(stream) = resolve_stream(ctx, to_unicode_obj) else {
        return Vec::new();
    };
    let Ok(decoded) = ctx.decoded.get_or_decode(ctx.bytes, &stream) else {
        return Vec::new();
    };
    let text = String::from_utf8_lossy(&decoded.data);
    let mut findings = Vec::new();
    let object_label = format!("{obj} {gen} obj");
    let ranges = parse_cmap_ranges(&text);
    let overlap = has_range_overlap(&ranges);
    if overlap {
        let (severity, confidence, impact) = font_followup_profile("font.cmap_range_overlap")
            .expect("profile exists for cmap overlap finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label.clone());
        meta.insert("font.cmap.range_count".into(), ranges.len().to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.cmap_range_overlap".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "ToUnicode CMap range overlap".into(),
            description: "ToUnicode CMap contains overlapping bfrange intervals.".into(),
            objects: vec![object_label.clone()],
            evidence: vec![span_to_evidence(stream.data_span, "ToUnicode CMap stream")],
            remediation: Some("Validate CMap ranges for overlap and decoding ambiguities.".into()),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    if ranges.len() > 4096 {
        let (severity, confidence, impact) =
            font_followup_profile("font.cmap_cardinality_anomalous")
                .expect("profile exists for cmap cardinality finding");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label.clone());
        meta.insert("font.cmap.range_count".into(), ranges.len().to_string());
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.cmap_cardinality_anomalous".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "ToUnicode CMap cardinality anomaly".into(),
            description: "ToUnicode CMap has an unusually large number of ranges.".into(),
            objects: vec![object_label.clone()],
            evidence: vec![span_to_evidence(stream.data_span, "ToUnicode CMap stream")],
            remediation: Some("Inspect CMap size and mapping intent for evasion patterns.".into()),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    if dict.has_name(b"/Subtype", b"/Type1") && !ranges.is_empty() && text.contains("begincidrange")
    {
        let (severity, confidence, impact) =
            font_followup_profile("font.cmap_subtype_inconsistent")
                .expect("profile exists for cmap subtype inconsistency");
        let mut meta = std::collections::HashMap::new();
        meta.insert("font.object_id".into(), object_label);
        findings.push(Finding {
            id: String::new(),
            surface: AttackSurface::StreamsAndFilters,
            kind: "font.cmap_subtype_inconsistent".into(),
            severity,
            confidence,
            impact: Some(impact),
            title: "Font subtype and CMap style inconsistent".into(),
            description: "Type1 font dictionary is paired with CID-style ToUnicode ranges.".into(),
            objects: vec![format!("{obj} {gen} obj")],
            evidence: vec![span_to_evidence(stream.data_span, "ToUnicode CMap subtype mismatch")],
            remediation: Some("Review font subtype and CMap pairing for consistency.".into()),
            meta,
            yara: None,
            positions: Vec::new(),
            ..Finding::default()
        });
    }
    findings
}

fn resolve_dict_from_obj<'a>(
    ctx: &'a sis_pdf_core::scan::ScanContext<'a>,
    obj: &'a sis_pdf_pdf::object::PdfObj<'a>,
) -> Option<PdfDict<'a>> {
    match &obj.atom {
        PdfAtom::Dict(dict) => Some(dict.clone()),
        PdfAtom::Ref { .. } => ctx.graph.resolve_ref(obj).and_then(|entry| match &entry.atom {
            PdfAtom::Dict(dict) => Some(dict.clone()),
            PdfAtom::Stream(stream) => Some(stream.dict.clone()),
            _ => None,
        }),
        PdfAtom::Stream(stream) => Some(stream.dict.clone()),
        _ => None,
    }
}

fn parse_cmap_ranges(text: &str) -> Vec<(u32, u32)> {
    let mut ranges = Vec::new();
    for line in text.lines() {
        if !line.contains('<') {
            continue;
        }
        let parts = line
            .split_whitespace()
            .filter(|token| token.starts_with('<') && token.ends_with('>'))
            .collect::<Vec<_>>();
        if parts.len() < 2 {
            continue;
        }
        let start = parse_hex_token(parts[0]);
        let end = parse_hex_token(parts[1]);
        if let (Some(start), Some(end)) = (start, end) {
            ranges.push((start.min(end), start.max(end)));
        }
    }
    ranges
}

fn parse_hex_token(token: &str) -> Option<u32> {
    let hex = token.trim_start_matches('<').trim_end_matches('>');
    u32::from_str_radix(hex, 16).ok()
}

fn has_range_overlap(ranges: &[(u32, u32)]) -> bool {
    let mut sorted = ranges.to_vec();
    sorted.sort_by_key(|range| range.0);
    let mut prev_end = None;
    for (start, end) in sorted {
        if let Some(prev) = prev_end {
            if start <= prev {
                return true;
            }
        }
        prev_end = Some(end);
    }
    false
}

fn font_followup_profile(kind: &str) -> Option<(Severity, Confidence, Impact)> {
    match kind {
        "font.type3_charproc_complexity_high" => {
            Some((Severity::Medium, Confidence::Probable, Impact::Medium))
        }
        "font.type3_charproc_resource_abuse" => {
            Some((Severity::High, Confidence::Probable, Impact::High))
        }
        "font.type3_charproc_recursion_like_pattern" => {
            Some((Severity::Medium, Confidence::Tentative, Impact::Medium))
        }
        "type3_charproc_suspicious_ops" => {
            Some((Severity::Medium, Confidence::Tentative, Impact::Medium))
        }
        "font.cmap_range_overlap" => Some((Severity::Medium, Confidence::Strong, Impact::Medium)),
        "font.cmap_cardinality_anomalous" => {
            Some((Severity::Medium, Confidence::Probable, Impact::Medium))
        }
        "font.cmap_subtype_inconsistent" => {
            Some((Severity::Medium, Confidence::Strong, Impact::Medium))
        }
        _ => None,
    }
}

fn resolve_stream<'a>(
    ctx: &'a sis_pdf_core::scan::ScanContext<'a>,
    obj: &'a sis_pdf_pdf::object::PdfObj<'a>,
) -> Option<PdfStream<'a>> {
    match &obj.atom {
        PdfAtom::Stream(st) => Some(st.clone()),
        PdfAtom::Ref { .. } => ctx.graph.resolve_ref(obj).and_then(|e| match &e.atom {
            PdfAtom::Stream(st) => Some(st.clone()),
            _ => None,
        }),
        _ => None,
    }
}

fn font_name_from_dict(dict: &PdfDict<'_>) -> Option<String> {
    let keys = [b"/BaseFont".as_slice(), b"/FontName".as_slice()];
    for key in keys {
        if let Some((_, obj)) = dict.get_first(key) {
            match &obj.atom {
                PdfAtom::Name(name) => {
                    return Some(String::from_utf8_lossy(&name.decoded).into());
                }
                PdfAtom::Str(text) => {
                    let decoded = match text {
                        sis_pdf_pdf::object::PdfStr::Literal { decoded, .. } => decoded.as_slice(),
                        sis_pdf_pdf::object::PdfStr::Hex { decoded, .. } => decoded.as_slice(),
                    };
                    return Some(String::from_utf8_lossy(decoded).into());
                }
                _ => {}
            }
        }
    }
    None
}

fn build_font_objects(object_label: &str, dict: &PdfDict<'_>) -> Vec<String> {
    let mut objects = vec![object_label.to_string()];
    if let Some(name) = font_name_from_dict(dict) {
        objects.push(name);
    }
    objects
}

fn looks_like_cff(data: &[u8]) -> bool {
    data.windows(4).any(|w| w == b"OTTO") || data.windows(3).any(|w| w == b"CFF")
}

fn map_severity(severity: FontSeverity) -> Severity {
    match severity {
        FontSeverity::Info => Severity::Info,
        FontSeverity::Low => Severity::Low,
        FontSeverity::Medium => Severity::Medium,
        FontSeverity::High => Severity::High,
    }
}

fn map_confidence(confidence: FontConfidence) -> Confidence {
    match confidence {
        FontConfidence::Heuristic => Confidence::Heuristic,
        FontConfidence::Probable => Confidence::Probable,
        FontConfidence::Strong => Confidence::Strong,
        FontConfidence::Certain => Confidence::Certain,
        FontConfidence::Tentative => Confidence::Tentative,
        FontConfidence::Weak => Confidence::Weak,
    }
}

#[cfg(test)]
mod tests {
    use sis_pdf_core::model::{Confidence, Impact, Severity};

    use super::{font_followup_profile, has_range_overlap, parse_cmap_ranges};

    #[test]
    fn cmap_range_overlap_detected() {
        let text = "<0001> <000A> <0041>\n<0005> <0010> <0051>\n";
        let ranges = parse_cmap_ranges(text);
        assert!(has_range_overlap(&ranges));
    }

    #[test]
    fn cmap_ranges_parse_basic_hex_pairs() {
        let text = "<0001> <0003> <0041>\n<0004> <0008> <0050>\n";
        let ranges = parse_cmap_ranges(text);
        assert_eq!(ranges.len(), 2);
        assert_eq!(ranges[0], (1, 3));
    }

    #[test]
    fn font_followup_profiles_match_expected_calibration() {
        let expected = [
            (
                "font.type3_charproc_complexity_high",
                Severity::Medium,
                Confidence::Probable,
                Impact::Medium,
            ),
            (
                "font.type3_charproc_resource_abuse",
                Severity::High,
                Confidence::Probable,
                Impact::High,
            ),
            (
                "font.type3_charproc_recursion_like_pattern",
                Severity::Medium,
                Confidence::Tentative,
                Impact::Medium,
            ),
            (
                "type3_charproc_suspicious_ops",
                Severity::Medium,
                Confidence::Tentative,
                Impact::Medium,
            ),
            ("font.cmap_range_overlap", Severity::Medium, Confidence::Strong, Impact::Medium),
            (
                "font.cmap_cardinality_anomalous",
                Severity::Medium,
                Confidence::Probable,
                Impact::Medium,
            ),
            (
                "font.cmap_subtype_inconsistent",
                Severity::Medium,
                Confidence::Strong,
                Impact::Medium,
            ),
        ];
        for (kind, severity, confidence, impact) in expected {
            let got = font_followup_profile(kind).expect("profile must exist");
            assert_eq!(got.0, severity, "severity drift for {kind}");
            assert_eq!(got.1, confidence, "confidence drift for {kind}");
            assert_eq!(got.2, impact, "impact drift for {kind}");
        }
    }
}
