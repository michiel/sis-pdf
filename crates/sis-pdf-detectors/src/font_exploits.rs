use anyhow::Result;

use sis_pdf_core::detect::{Cost, Detector, Needs};
use sis_pdf_core::model::{AttackSurface, Confidence, Finding, Severity};
use sis_pdf_core::scan::span_to_evidence;
use sis_pdf_pdf::decode::stream_filters;
use sis_pdf_pdf::object::{PdfAtom, PdfStream};

use crate::entry_dict;

pub struct FontExploitDetector;

impl Detector for FontExploitDetector {
    fn id(&self) -> &'static str {
        "font_exploit"
    }

    fn surface(&self) -> AttackSurface {
        AttackSurface::StreamsAndFilters
    }

    fn needs(&self) -> Needs {
        Needs::OBJECT_GRAPH
    }

    fn cost(&self) -> Cost {
        Cost::Moderate
    }

    fn run(&self, ctx: &sis_pdf_core::scan::ScanContext) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        for entry in &ctx.graph.objects {
            let Some(dict) = entry_dict(entry) else { continue };
            for key in [b"/FontFile".as_slice(), b"/FontFile2".as_slice(), b"/FontFile3".as_slice()] {
                if let Some((_, obj)) = dict.get_first(key) {
                    if let Some(stream) = resolve_stream(ctx, obj) {
                        let span = stream.data_span;
                        let raw_len = span.len() as usize;
                        let filters = stream_filters(&stream.dict);
                        let mut meta = std::collections::HashMap::new();
                        meta.insert("font.stream_len".into(), raw_len.to_string());
                        if !filters.is_empty() {
                            meta.insert("font.stream_filters".into(), filters.join(","));
                        }
                        if raw_len > 2 * 1024 * 1024 {
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_payload_present".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Probable,
                                title: "Large embedded font payload".into(),
                                description: "Embedded font stream size exceeds expected bounds.".into(),
                                objects: vec![format!("{} {} obj", entry.obj, entry.gen)],
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some("Inspect embedded font tables for anomalies.".into()),
                                meta: meta.clone(),
                                yara: None,
                            });
                        }
                        if looks_like_cff(ctx.bytes, &stream) {
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_table_anomaly".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Heuristic,
                                title: "Suspicious font table signature".into(),
                                description: "Font stream contains CFF/OTF markers that warrant inspection.".into(),
                                objects: vec![format!("{} {} obj", entry.obj, entry.gen)],
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some("Validate font table structure and limits.".into()),
                                meta,
                                yara: None,
                            });
                        }
                    }
                }
            }
        }
        Ok(findings)
    }
}

fn resolve_stream<'a>(
    ctx: &'a sis_pdf_core::scan::ScanContext<'a>,
    obj: &'a sis_pdf_pdf::object::PdfObj<'a>,
) -> Option<PdfStream<'a>> {
    match &obj.atom {
        PdfAtom::Stream(st) => Some(st.clone()),
        PdfAtom::Ref { .. } => ctx.graph.resolve_ref(obj).and_then(|e| match &e.atom {
            PdfAtom::Stream(st) => Some(st.clone()),
            _ => None,
        }),
        _ => None,
    }
}

fn looks_like_cff(bytes: &[u8], st: &PdfStream<'_>) -> bool {
    let start = st.data_span.start as usize;
    let end = st.data_span.end.min(bytes.len() as u64) as usize;
    if start >= end || end > bytes.len() {
        return false;
    }
    let slice = &bytes[start..end];
    slice.windows(4).any(|w| w == b"OTTO") || slice.windows(3).any(|w| w == b"CFF")
}
