use anyhow::Result;

use font_analysis::model::{Confidence as FontConfidence, Severity as FontSeverity};
use font_analysis::{analyse_font, FontAnalysisConfig};
use sis_pdf_core::detect::{Cost, Detector, Needs};
use sis_pdf_core::model::{AttackSurface, Confidence, Finding, Impact, Severity};
use sis_pdf_core::scan::span_to_evidence;
use sis_pdf_core::security_log::{SecurityDomain, SecurityEvent};
use sis_pdf_pdf::decode::stream_filters;
use sis_pdf_pdf::object::{PdfAtom, PdfDict, PdfStream};
use tracing::Level;

use crate::entry_dict;

pub struct FontExploitDetector;

impl Detector for FontExploitDetector {
    fn id(&self) -> &'static str {
        "font_exploit"
    }

    fn surface(&self) -> AttackSurface {
        AttackSurface::StreamsAndFilters
    }

    fn needs(&self) -> Needs {
        Needs::OBJECT_GRAPH
    }

    fn cost(&self) -> Cost {
        Cost::Moderate
    }

    fn run(&self, ctx: &sis_pdf_core::scan::ScanContext) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        let cfg = FontAnalysisConfig {
            enabled: ctx.options.font_analysis.enabled,
            dynamic_enabled: ctx.options.font_analysis.dynamic_enabled,
            dynamic_timeout_ms: ctx.options.font_analysis.dynamic_timeout_ms,
            max_fonts: ctx.options.font_analysis.max_fonts,
            signature_matching_enabled: ctx.options.font_analysis.signature_matching_enabled,
            signature_directory: ctx.options.font_analysis.signature_directory.clone(),
            ..Default::default()
        };
        if !cfg.enabled {
            return Ok(findings);
        }
        let mut seen = 0usize;
        for entry in &ctx.graph.objects {
            let Some(dict) = entry_dict(entry) else {
                continue;
            };
            for key in [
                b"/FontFile".as_slice(),
                b"/FontFile2".as_slice(),
                b"/FontFile3".as_slice(),
            ] {
                if let Some((_, obj)) = dict.get_first(key) {
                    if let Some(stream) = resolve_stream(ctx, obj) {
                        if seen >= ctx.options.font_analysis.max_fonts {
                            SecurityEvent {
                                level: Level::WARN,
                                domain: SecurityDomain::Detection,
                                severity: sis_pdf_core::model::Severity::Low,
                                kind: "font_analysis_limit",
                                policy: None,
                                object_id: None,
                                object_type: None,
                                vector: None,
                                technique: None,
                                confidence: None,
                                message: "Font analysis limit reached; skipping remaining fonts",
                            }
                            .emit();
                            return Ok(findings);
                        }
                        seen += 1;
                        let span = stream.data_span;
                        let raw_len = span.len() as usize;
                        let filters = stream_filters(&stream.dict);
                        let mut base_meta = std::collections::HashMap::new();
                        base_meta.insert("font.stream_len".into(), raw_len.to_string());
                        if !filters.is_empty() {
                            base_meta.insert("font.stream_filters".into(), filters.join(","));
                        }
                        let object_label = format!("{} {} obj", entry.obj, entry.gen);
                        if let Some(font_name) = font_name_from_dict(dict) {
                            base_meta.insert("font.name".into(), font_name.clone());
                        }
                        base_meta.insert("font.object_id".into(), object_label.clone());

                        let decoded = match ctx.decoded.get_or_decode(ctx.bytes, &stream) {
                            Ok(decoded) => decoded,
                            Err(err) => {
                                let mut meta = base_meta.clone();
                                meta.insert("font.decode_error".into(), err.to_string());
                                findings.push(Finding {
                                    id: String::new(),
                                    surface: self.surface(),
                                    kind: "font.invalid_structure".into(),
                                    severity: Severity::Medium,
                                    confidence: Confidence::Probable,
                                    impact: None,
                                    title: "Font stream decode failed".into(),
                                    description: "Embedded font stream could not be decoded."
                                        .into(),
                                    objects: build_font_objects(&object_label, dict),
                                    evidence: vec![span_to_evidence(
                                        stream.data_span,
                                        "Font stream",
                                    )],
                                    remediation: Some(
                                        "Inspect embedded font streams and filters.".into(),
                                    ),
                                    meta,
                                    yara: None,
                                    position: None,
                                    positions: Vec::new(),
                                    ..Finding::default()
                                });
                                continue;
                            }
                        };

                        if raw_len > 2 * 1024 * 1024 {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_payload_present".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Probable,
                                impact: None,
                                title: "Large embedded font payload".into(),
                                description: "Embedded font stream size exceeds expected bounds."
                                    .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Inspect embedded font tables for anomalies.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                        if looks_like_cff(&decoded.data) {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_table_anomaly".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Heuristic,
                                impact: None,
                                title: "Suspicious font table signature".into(),
                                description:
                                    "Font stream contains CFF/OTF markers that warrant inspection."
                                        .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate font table structure and limits.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }

                        let analysis = analyse_font(&decoded.data, &cfg);
                        for finding in analysis.findings {
                            let mut meta = base_meta.clone();
                            meta.extend(finding.meta);
                            let impact = match finding.kind.as_str() {
                                "font.gvar_glyph_count_mismatch" => Some(Impact::High),
                                "font.gvar_offsets_disorder" => Some(Impact::Medium),
                                "font.anomalous_variation_table" => Some(Impact::Medium),
                                _ => None,
                            };
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: finding.kind,
                                severity: map_severity(finding.severity),
                                confidence: map_confidence(finding.confidence),
                                impact,
                                title: finding.title,
                                description: finding.description,
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate embedded font tables and render paths.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                    }
                }
            }
        }
        Ok(findings)
    }
}

fn resolve_stream<'a>(
    ctx: &'a sis_pdf_core::scan::ScanContext<'a>,
    obj: &'a sis_pdf_pdf::object::PdfObj<'a>,
) -> Option<PdfStream<'a>> {
    match &obj.atom {
        PdfAtom::Stream(st) => Some(st.clone()),
        PdfAtom::Ref { .. } => ctx.graph.resolve_ref(obj).and_then(|e| match &e.atom {
            PdfAtom::Stream(st) => Some(st.clone()),
            _ => None,
        }),
        _ => None,
    }
}

fn font_name_from_dict(dict: &PdfDict<'_>) -> Option<String> {
    let keys = [b"/BaseFont".as_slice(), b"/FontName".as_slice()];
    for key in keys {
        if let Some((_, obj)) = dict.get_first(key) {
            match &obj.atom {
                PdfAtom::Name(name) => {
                    return Some(String::from_utf8_lossy(&name.decoded).into());
                }
                PdfAtom::Str(text) => {
                    let decoded = match text {
                        sis_pdf_pdf::object::PdfStr::Literal { decoded, .. } => decoded.as_slice(),
                        sis_pdf_pdf::object::PdfStr::Hex { decoded, .. } => decoded.as_slice(),
                    };
                    return Some(String::from_utf8_lossy(decoded).into());
                }
                _ => {}
            }
        }
    }
    None
}

fn build_font_objects(object_label: &str, dict: &PdfDict<'_>) -> Vec<String> {
    let mut objects = vec![object_label.to_string()];
    if let Some(name) = font_name_from_dict(dict) {
        objects.push(name);
    }
    objects
}

fn looks_like_cff(data: &[u8]) -> bool {
    data.windows(4).any(|w| w == b"OTTO") || data.windows(3).any(|w| w == b"CFF")
}

fn map_severity(severity: FontSeverity) -> Severity {
    match severity {
        FontSeverity::Info => Severity::Info,
        FontSeverity::Low => Severity::Low,
        FontSeverity::Medium => Severity::Medium,
        FontSeverity::High => Severity::High,
    }
}

fn map_confidence(confidence: FontConfidence) -> Confidence {
    match confidence {
        FontConfidence::Heuristic => Confidence::Heuristic,
        FontConfidence::Probable => Confidence::Probable,
        FontConfidence::Strong => Confidence::Strong,
        FontConfidence::Certain => Confidence::Certain,
        FontConfidence::Tentative => Confidence::Tentative,
        FontConfidence::Weak => Confidence::Weak,
    }
}
