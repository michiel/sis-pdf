use anyhow::Result;

use font_analysis::model::{Confidence as FontConfidence, Severity as FontSeverity};
use font_analysis::{analyse_font, FontAnalysisConfig};
use sis_pdf_core::detect::{Cost, Detector, Needs};
use sis_pdf_core::model::{AttackSurface, Confidence, Finding, Impact, Severity};
use sis_pdf_core::scan::span_to_evidence;
use sis_pdf_core::security_log::{SecurityDomain, SecurityEvent};
use sis_pdf_pdf::decode::stream_filters;
use sis_pdf_pdf::graph::ObjProvenance;
use sis_pdf_pdf::object::{PdfAtom, PdfDict, PdfStream};
use tracing::Level;

use crate::entry_dict;

pub struct FontExploitDetector;

impl Detector for FontExploitDetector {
    fn id(&self) -> &'static str {
        "font_exploit"
    }

    fn surface(&self) -> AttackSurface {
        AttackSurface::StreamsAndFilters
    }

    fn needs(&self) -> Needs {
        Needs::OBJECT_GRAPH
    }

    fn cost(&self) -> Cost {
        Cost::Moderate
    }

    fn run(&self, ctx: &sis_pdf_core::scan::ScanContext) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        let cfg = FontAnalysisConfig {
            enabled: ctx.options.font_analysis.enabled,
            dynamic_enabled: ctx.options.font_analysis.dynamic_enabled,
            dynamic_timeout_ms: ctx.options.font_analysis.dynamic_timeout_ms,
            max_fonts: ctx.options.font_analysis.max_fonts,
            signature_matching_enabled: ctx.options.font_analysis.signature_matching_enabled,
            signature_directory: ctx.options.font_analysis.signature_directory.clone(),
            ..Default::default()
        };
        if !cfg.enabled {
            return Ok(findings);
        }
        let mut seen = 0usize;
        for entry in &ctx.graph.objects {
            let Some(dict) = entry_dict(entry) else {
                continue;
            };
            findings.extend(font_structure_consistency_findings(
                entry.obj,
                entry.gen,
                dict,
                entry.full_span,
            ));
            for key in [b"/FontFile".as_slice(), b"/FontFile2".as_slice(), b"/FontFile3".as_slice()]
            {
                if let Some((_, obj)) = dict.get_first(key) {
                    if let Some(stream) = resolve_stream(ctx, obj) {
                        if seen >= ctx.options.font_analysis.max_fonts {
                            SecurityEvent {
                                level: Level::WARN,
                                domain: SecurityDomain::Detection,
                                severity: sis_pdf_core::model::Severity::Low,
                                kind: "font_analysis_limit",
                                policy: None,
                                object_id: None,
                                object_type: None,
                                vector: None,
                                technique: None,
                                confidence: None,
                                fatal: false,
                                message: "Font analysis limit reached; skipping remaining fonts",
                            }
                            .emit();
                            return Ok(findings);
                        }
                        seen += 1;
                        let span = stream.data_span;
                        let raw_len = span.len() as usize;
                        let filters = stream_filters(&stream.dict);
                        let mut base_meta = std::collections::HashMap::new();
                        base_meta.insert("font.stream_len".into(), raw_len.to_string());
                        if !filters.is_empty() {
                            base_meta.insert("font.stream_filters".into(), filters.join(","));
                        }
                        let object_label = format!("{} {} obj", entry.obj, entry.gen);
                        if let Some(font_name) = font_name_from_dict(dict) {
                            base_meta.insert("font.name".into(), font_name.clone());
                        }
                        base_meta.insert("font.object_id".into(), object_label.clone());
                        base_meta.insert(
                            "font.object_provenance".into(),
                            provenance_label(entry.provenance),
                        );
                        let revisions = ctx.graph.all_objects_by_id(entry.obj, entry.gen).len();
                        if revisions > 1 {
                            base_meta.insert(
                                "font.object_shadowed_revisions".into(),
                                revisions.to_string(),
                            );
                        }
                        if ctx
                            .graph
                            .deviations
                            .iter()
                            .any(|deviation| deviation.kind.contains("xref"))
                        {
                            base_meta.insert("font.xref_conflict_signal".into(), "true".into());
                        }

                        let decoded = match ctx.decoded.get_or_decode(ctx.bytes, &stream) {
                            Ok(decoded) => decoded,
                            Err(err) => {
                                let mut meta = base_meta.clone();
                                meta.insert("font.decode_error".into(), err.to_string());
                                findings.push(Finding {
                                    id: String::new(),
                                    surface: self.surface(),
                                    kind: "font.invalid_structure".into(),
                                    severity: Severity::Medium,
                                    confidence: Confidence::Probable,
                                    impact: None,
                                    title: "Font stream decode failed".into(),
                                    description: "Embedded font stream could not be decoded."
                                        .into(),
                                    objects: build_font_objects(&object_label, dict),
                                    evidence: vec![span_to_evidence(
                                        stream.data_span,
                                        "Font stream",
                                    )],
                                    remediation: Some(
                                        "Inspect embedded font streams and filters.".into(),
                                    ),
                                    meta,
                                    yara: None,
                                    position: None,
                                    positions: Vec::new(),
                                    ..Finding::default()
                                });
                                continue;
                            }
                        };

                        if revisions > 1 {
                            let mut provenance_meta = base_meta.clone();
                            provenance_meta.insert(
                                "font.fontfile_key".into(),
                                String::from_utf8_lossy(key).to_string(),
                            );
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font.provenance_incremental_override".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Strong,
                                impact: Some(Impact::Medium),
                                title: "Font object overridden across revisions".into(),
                                description:
                                    "The font object identifier appears in multiple revisions, indicating override behaviour."
                                        .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font object revision override")],
                                remediation: Some(
                                    "Inspect historical revisions of embedded fonts for hidden payload changes.".into(),
                                ),
                                meta: provenance_meta.clone(),
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });

                            if ctx
                                .graph
                                .deviations
                                .iter()
                                .any(|deviation| deviation.kind.contains("xref"))
                            {
                                findings.push(Finding {
                                    id: String::new(),
                                    surface: AttackSurface::FileStructure,
                                    kind: "resource.provenance_xref_conflict".into(),
                                    severity: Severity::High,
                                    confidence: Confidence::Probable,
                                    impact: Some(Impact::High),
                                    title: "Resource provenance intersects xref conflict".into(),
                                    description:
                                        "Font resource revision overrides co-occur with xref conflict signals."
                                            .into(),
                                    objects: build_font_objects(&object_label, dict),
                                    evidence: vec![span_to_evidence(stream.data_span, "Resource provenance xref conflict")],
                                    remediation: Some(
                                        "Validate xref consistency and inspect font object history across revisions.".into(),
                                    ),
                                    meta: provenance_meta,
                                    yara: None,
                                    position: None,
                                    positions: Vec::new(),
                                    ..Finding::default()
                                });
                            }
                        }

                        if raw_len > 2 * 1024 * 1024 {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_payload_present".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Probable,
                                impact: None,
                                title: "Large embedded font payload".into(),
                                description: "Embedded font stream size exceeds expected bounds."
                                    .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Inspect embedded font tables for anomalies.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                        if looks_like_cff(&decoded.data) {
                            let meta = base_meta.clone();
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: "font_table_anomaly".into(),
                                severity: Severity::Medium,
                                confidence: Confidence::Heuristic,
                                impact: None,
                                title: "Suspicious font table signature".into(),
                                description:
                                    "Font stream contains CFF/OTF markers that warrant inspection."
                                        .into(),
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate font table structure and limits.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }

                        let analysis = analyse_font(&decoded.data, &cfg);
                        for finding in analysis.findings {
                            let mut meta = base_meta.clone();
                            meta.extend(finding.meta);
                            let impact = match finding.kind.as_str() {
                                "font.gvar_glyph_count_mismatch" => Some(Impact::High),
                                "font.gvar_offsets_disorder" => Some(Impact::Medium),
                                "font.anomalous_variation_table" => Some(Impact::Medium),
                                _ => None,
                            };
                            findings.push(Finding {
                                id: String::new(),
                                surface: self.surface(),
                                kind: finding.kind,
                                severity: map_severity(finding.severity),
                                confidence: map_confidence(finding.confidence),
                                impact,
                                title: finding.title,
                                description: finding.description,
                                objects: build_font_objects(&object_label, dict),
                                evidence: vec![span_to_evidence(stream.data_span, "Font stream")],
                                remediation: Some(
                                    "Validate embedded font tables and render paths.".into(),
                                ),
                                meta,
                                yara: None,
                                position: None,
                                positions: Vec::new(),
                                ..Finding::default()
                            });
                        }
                    }
                }
            }
        }
        Ok(findings)
    }
}

fn font_structure_consistency_findings(
    obj: u32,
    gen: u16,
    dict: &PdfDict<'_>,
    span: sis_pdf_pdf::span::Span,
) -> Vec<Finding> {
    let mut findings = Vec::new();
    let object_label = format!("{obj} {gen} obj");

    if let Some((_, subtype_obj)) = dict.get_first(b"/Subtype") {
        if let PdfAtom::Name(subtype) = &subtype_obj.atom {
            let subtype_label = String::from_utf8_lossy(&subtype.decoded).to_string();
            if dict.get_first(b"/FontFile").is_some() && subtype_label != "/Type1" {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert("font.subtype".into(), subtype_label.clone());
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_subtype_mismatch".into(),
                    severity: Severity::High,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::High),
                    title: "Font subtype and embedded stream mismatch".into(),
                    description:
                        "Font dictionary subtype is inconsistent with embedded /FontFile usage."
                            .into(),
                    objects: vec![object_label.clone()],
                    evidence: vec![span_to_evidence(span, "Font subtype mismatch")],
                    remediation: Some(
                        "Validate font descriptor subtype and stream key consistency.".into(),
                    ),
                    meta,
                    yara: None,
                    position: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
            if dict.get_first(b"/FontFile3").is_some() && dict.get_first(b"/FontFile").is_some() {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert("font.subtype".into(), subtype_label);
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_subtype_mismatch".into(),
                    severity: Severity::High,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::High),
                    title: "Conflicting embedded font stream keys".into(),
                    description:
                        "Font dictionary declares conflicting embedded stream keys (/FontFile and /FontFile3).".into(),
                    objects: vec![object_label.clone()],
                    evidence: vec![span_to_evidence(span, "Conflicting font stream keys")],
                    remediation: Some(
                        "Inspect descriptor consistency and remove conflicting embedded stream declarations.".into(),
                    ),
                    meta,
                    yara: None,
                    position: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
        }
    }

    if let Some((_, encoding)) = dict.get_first(b"/Encoding") {
        if matches!(encoding.atom, PdfAtom::Null) {
            let mut meta = std::collections::HashMap::new();
            meta.insert("font.object_id".into(), object_label.clone());
            findings.push(Finding {
                id: String::new(),
                surface: AttackSurface::StreamsAndFilters,
                kind: "font.structure_encoding_inconsistent".into(),
                severity: Severity::Medium,
                confidence: Confidence::Strong,
                impact: Some(Impact::Medium),
                title: "Inconsistent font encoding declaration".into(),
                description: "Font dictionary contains a null /Encoding declaration.".into(),
                objects: vec![object_label.clone()],
                evidence: vec![span_to_evidence(span, "Font encoding inconsistency")],
                remediation: Some("Validate /Encoding and related cmap declarations.".into()),
                meta,
                yara: None,
                position: None,
                positions: Vec::new(),
                ..Finding::default()
            });
        }
    }

    if let Some((_, cid_to_gid)) = dict.get_first(b"/CIDToGIDMap") {
        if let PdfAtom::Name(name) = &cid_to_gid.atom {
            if name.decoded.as_slice() != b"/Identity" {
                let mut meta = std::collections::HashMap::new();
                meta.insert("font.object_id".into(), object_label.clone());
                meta.insert(
                    "font.cid_to_gid_map".into(),
                    String::from_utf8_lossy(&name.decoded).to_string(),
                );
                findings.push(Finding {
                    id: String::new(),
                    surface: AttackSurface::StreamsAndFilters,
                    kind: "font.structure_mapping_anomalous".into(),
                    severity: Severity::Medium,
                    confidence: Confidence::Probable,
                    impact: Some(Impact::Medium),
                    title: "Anomalous CIDToGIDMap declaration".into(),
                    description:
                        "Font dictionary uses a non-Identity CIDToGIDMap name, which is uncommon and can hide mapping abuse."
                            .into(),
                    objects: vec![object_label],
                    evidence: vec![span_to_evidence(span, "Font mapping anomaly")],
                    remediation: Some(
                        "Inspect character map behaviour and downstream renderer interpretation.".into(),
                    ),
                    meta,
                    yara: None,
                    position: None,
                    positions: Vec::new(),
                    ..Finding::default()
                });
            }
        }
    }

    findings
}

fn provenance_label(provenance: ObjProvenance) -> String {
    match provenance {
        ObjProvenance::Indirect => "indirect".into(),
        ObjProvenance::ObjStm { obj, gen } => format!("objstm:{}:{}", obj, gen),
        ObjProvenance::CarvedStream { obj, gen } => format!("carved_stream:{}:{}", obj, gen),
    }
}

fn resolve_stream<'a>(
    ctx: &'a sis_pdf_core::scan::ScanContext<'a>,
    obj: &'a sis_pdf_pdf::object::PdfObj<'a>,
) -> Option<PdfStream<'a>> {
    match &obj.atom {
        PdfAtom::Stream(st) => Some(st.clone()),
        PdfAtom::Ref { .. } => ctx.graph.resolve_ref(obj).and_then(|e| match &e.atom {
            PdfAtom::Stream(st) => Some(st.clone()),
            _ => None,
        }),
        _ => None,
    }
}

fn font_name_from_dict(dict: &PdfDict<'_>) -> Option<String> {
    let keys = [b"/BaseFont".as_slice(), b"/FontName".as_slice()];
    for key in keys {
        if let Some((_, obj)) = dict.get_first(key) {
            match &obj.atom {
                PdfAtom::Name(name) => {
                    return Some(String::from_utf8_lossy(&name.decoded).into());
                }
                PdfAtom::Str(text) => {
                    let decoded = match text {
                        sis_pdf_pdf::object::PdfStr::Literal { decoded, .. } => decoded.as_slice(),
                        sis_pdf_pdf::object::PdfStr::Hex { decoded, .. } => decoded.as_slice(),
                    };
                    return Some(String::from_utf8_lossy(decoded).into());
                }
                _ => {}
            }
        }
    }
    None
}

fn build_font_objects(object_label: &str, dict: &PdfDict<'_>) -> Vec<String> {
    let mut objects = vec![object_label.to_string()];
    if let Some(name) = font_name_from_dict(dict) {
        objects.push(name);
    }
    objects
}

fn looks_like_cff(data: &[u8]) -> bool {
    data.windows(4).any(|w| w == b"OTTO") || data.windows(3).any(|w| w == b"CFF")
}

fn map_severity(severity: FontSeverity) -> Severity {
    match severity {
        FontSeverity::Info => Severity::Info,
        FontSeverity::Low => Severity::Low,
        FontSeverity::Medium => Severity::Medium,
        FontSeverity::High => Severity::High,
    }
}

fn map_confidence(confidence: FontConfidence) -> Confidence {
    match confidence {
        FontConfidence::Heuristic => Confidence::Heuristic,
        FontConfidence::Probable => Confidence::Probable,
        FontConfidence::Strong => Confidence::Strong,
        FontConfidence::Certain => Confidence::Certain,
        FontConfidence::Tentative => Confidence::Tentative,
        FontConfidence::Weak => Confidence::Weak,
    }
}
